<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[一世烟雨江南]]></title>
  <subtitle><![CDATA[有情怀的程序员，热爱设计的工程师。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://sergiochan.github.io/"/>
  <updated>2016-02-17T04:06:20.000Z</updated>
  <id>http://sergiochan.github.io/</id>
  
  <author>
    <name><![CDATA[Sergio Chan]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[不要想当然的就使用UITableView]]></title>
    <link href="http://sergiochan.github.io/2016/02/16/%E4%B8%8D%E8%A6%81%E6%83%B3%E5%BD%93%E7%84%B6%E7%9A%84%E5%B0%B1%E4%BD%BF%E7%94%A8UITableView/"/>
    <id>http://sergiochan.github.io/2016/02/16/不要想当然的就使用UITableView/</id>
    <published>2016-02-16T08:41:50.000Z</published>
    <updated>2016-02-17T04:06:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>一直想写一篇UITableView使用经验的干货，因为TableView实在是太万能了，它帮你维护了ContentSize，数据源加载，一些事件的回调还有最重要的是视图的重用，以至于有些项目（什么电商，什么O2O这类的应用）满地都是TableView，所以在一般项目中很容易出现对于TableView的滥用或者是误用。然而由于这种事情仁者见仁，智者见智，因此在一个项目组里，一些错误的风气很容易被持续甚至发扬下去。</p>
<p>我不打算在性能优化方面深入介绍，因为已经有很多关于TableView性能优化的博客了，我可能会稍微提到一些。这篇博客主要是关于整体结构，使用经验这方面的整理，让更多还没踩坑或者正在踩坑的同学们及时醒悟。</p>
<h2 id="u4E0D_u8981_u8BD5_u56FE_u8FC7_u5206_u7684_u53BB_u590D_u7528_u4E00_u4E2ATableViewController"><a href="#u4E0D_u8981_u8BD5_u56FE_u8FC7_u5206_u7684_u53BB_u590D_u7528_u4E00_u4E2ATableViewController" class="headerlink" title="不要试图过分的去复用一个TableViewController"></a>不要试图过分的去复用一个TableViewController</h2><p>想想在使用TableViewController或者包含了TableView的Controller的时候，如果遇到了如下的这类场景，我们一般会怎么做？</p>
<ol>
<li>联系人列表，有两个场景要使用，一个是好友列表，一个是手机联系人列表，甚至还有更多类型的联系人列表。好友列表中需要展示用户信息，例如头像，用户名，性别，等级之类，点击头像可以进入好友的个人主页，点击Cell可以进入聊天页面；而手机联系人列表中需要展示手机号，联系人姓名，头像等信息，需要标识是否可以发送邀请，点击Cell不会响应，点击头像进入发送邀请页面。</li>
<li>个人主页，样式基本一致，但是有三个场景要使用，分为好友个人主页，非好友个人主页和自己的个人主页。展示的基本信息都一样，例如用户名，姓名，性别，生日，等级这些信息，但是非好友和好友加载的数据源和显示的数据有略微不同，例如好友显示的是姓名，而非好友显示的是用户名。而自己的个人主页展示的数据更多，一些其他用户不可见的信息对自己全部都是可见的。同时好友个人主页可以编辑备注名或者分组，自己的个人主页能修改全部信息和上传头像，且修改要在当前页面直接修改，非好友个人主页可以发送好友请求，或者花费一些金币获取更详细的个人信息。</li>
</ol>
<p>以上这两个实例场景在基本的带一定社交功能的应用中都会普遍出现。大部分开发者对第一个场景的解决办法都是写在同一个控制器中，当然，这里也和一些产品经理对于需求顺序和需求提前预测的忽视有关。一些情况里都是先实现了好友列表然后才要加入手机联系人列表，这样，在基本结构类似的情况下，为了节约迭代工作成本，在同一个控制器中修改代码无可厚非。我们可以简单的对TableView的数据源进行区分，对TableView的delegate回调进行判断，从而将两套TableView的逻辑写在一个控制器中，实现高聚合。然而，在第一个场景里并不明显的弊端，会在我描述的这个第二个场景里丑恶毕露。在考虑复用TableView的时候，<strong>你需要考虑高聚合的性价比</strong>，如果到了一定规模或者复杂度的时候，高聚合反而会给结构带来破坏，这时候高聚合的性价比非常低，在实际项目中对于产品结构的稳定性和将来的迭代性就会开始不断的产生负面的影响。</p>
<p>在第二个场景下，我见过这些用法：用枚举来标识当前TableView的类型，在所有数据源和Delegate回调的地方加上判断；给TableView加Tag；在Cell中加判断来区分不同的显示和不同的操作响应；甚至用进入个人主页的时候传入的userID来作为不同入口的判断。这些用法听起来虽然是低效一些，但是好像没什么大的问题，因为实际上每次TableView的加载和事件回调都可以被正常响应。然而我想总结的是这么一种习惯问题：当一个控制器被你不断的以这种形式往上加代码，几套逻辑被强制塞到同一个控制器中，这就像那个靠泥土和石头垒了七层楼的哥们一样，当你再视图往上添加一些重要的，新的东西的时候，他可能就全盘崩溃了，甚至让你不知道从何下手。</p>
<p>在实际项目中，你永远想象不到随着需求的增加，这些东西可能被怎么样的复用，而每一次复用，即使是很微小的不同，也是在破坏着代码的拓展性。你看看下面这个TableView是怎么被复用的就会知道了。</p>
<figure class="highlight crystal"><table><tr><td class="code"><pre><span class="line">typedef <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="constant">DataSourceTypeAllContacts</span> = <span class="number">0</span>,          </span><br><span class="line">    <span class="constant">DataSourceTypeAllGroup</span>,                 </span><br><span class="line">    <span class="constant">DataSourceTypeFriendContacts</span>,           </span><br><span class="line">    <span class="constant">DataSourceTypeAddGroupContacts</span>,         </span><br><span class="line">    <span class="constant">DataSourceTypeAllContactsSearch</span>,        </span><br><span class="line">    <span class="constant">DataSourceTypeAllGroupSearch</span>,           </span><br><span class="line">    <span class="constant">DataSourceTypeFriendContactsSearch</span>,     </span><br><span class="line">    <span class="constant">DataSourceTypeAddGroupContactsSearch</span>,   </span><br><span class="line">&#125;<span class="constant">DataSourceType</span>;</span><br></pre></td></tr></table></figure>
<p>这只是一个简单的联系人列表，但是在实际项目中，他被以这种简单低效的形式复用了8次，这就使你的代码变得越来越难以维护，每一次加载都加入了大量的判断，对于团队的其他成员，接手或者在你的代码基础上添加功能都会变得极其蛋疼。</p>
<p>在实际项目开发中，你需要将你的代码<strong>可读性，可维护性，可拓展性</strong>放在首位，而不是想着如何用最少代码去实现一个功能。当然，如果在保证了这三件事情的基础上还能够用最少的代码，那大概就是真大神了。但是对于更大多数的开发者来说，你需要将这三件事情放在第一位。</p>
<p>对于上面的这个复用了8次的TableView来说，还是有可能的优化空间的。例如，当数据源的类型一致，只是获取的方法不同，例如获取群组成员列表和好友列表，TableView的数据源数组中的数据类型是一样的，那么这个时候只要在加载数据的时候做个区分，而不用再TableView加载数据源的时候做区分。这里的意思是，在Cell的结构可以复用的情况下，Cell也可以复用，将TableView的一些复用逻辑转移到Cell中去。当然，如果Cell结构差异很大，或者你需要用xib来定义Cell的布局，那对于Cell的复用就要更加的小心。</p>
<p>当然，说了这么多，还是标题的一句话，<strong>不要试图过分的去复用一个TableViewController</strong>，这是一个好习惯，也会让你的队友们觉得你写的结构很容易看懂。在遇到较为复杂，或在可预见时间范围内有可能出现新的附加需求的功能模块的时候，尽量分开文件写，可以把多个控制器需要共用的部件封装出来，减少重复的代码量。</p>
<h2 id="u5982_u679C_u6211_u8981_u5728_u540C_u4E00_u4E2A_u63A7_u5236_u5668_u4E2D_u590D_u7528TableView_u5462_uFF1F"><a href="#u5982_u679C_u6211_u8981_u5728_u540C_u4E00_u4E2A_u63A7_u5236_u5668_u4E2D_u590D_u7528TableView_u5462_uFF1F" class="headerlink" title="如果我要在同一个控制器中复用TableView呢？"></a>如果我要在同一个控制器中复用TableView呢？</h2><p>如果有这么一个需求：</p>
<ul>
<li>在我的个人中心页面中，要根据我的不同用户状态显示几乎完全不同的tableview。有这几种状态，例如注册未填写信息，填写信息未提交审核，正在审核，审核通过，修改信息正在审核，这些状态甚至有可能更多，这时候该怎么办？</li>
</ul>
<p>在上一小节中的第二个场景中，我们已经将几种逻辑上有区分的个人中心拆分开来了。但是如果遇到同一个控制器中的tableView仍然会出现多种情况的时候，我们无法在上层继续拆分了，否则就会做很多多余的工作。这时候我们可以有以下这么几种解决办法：</p>
<ol>
<li>根据用户状态的枚举来在tableView的delegate和datasource加上大量的switch来实现入口的区分，这时候我们其实是使用了同一个tableView，并且将多路复用的选择放到了tableView去loadData的时候。这个方法就是最简单也是最笨重的，很多开发者在不考虑持续性的时候很容易走上这条不归路。</li>
<li>采用一个通用的cellModel，在数据源加载的时候就对多路复用进行了选择，cellModel的属性里有样式的枚举类型，cell的高度，数据对象等等，而且扩展性也还行。但是弊端就在于，虽然这种方法掩盖了第一种方法笨重的外表，但是在cellForRow这些加载过程中，仍然需要对cellModel的属性进行判断。虽然这些操作也是可以被封装出来的，但是仍然很臃肿，特别是同一个控制器的复用场景不断增加的情况下，cellForRow这个方法的可读性仍然很差。</li>
<li>根据数据源，也就是用户状态来返回不同的tableView，由tableView自己来维护自己的delegate和datasource，这样把所有的加载逻辑写在tableView中，根据情况而定是否要返回一个新的tableView。这样多路复用的选择其实就发生在了返回tableView的操作里，可以避免在控制器中出现臃肿的代码。</li>
</ol>
<blockquote>
<p>我不确定第三种方法是否是最佳实践。希望能有一些探讨~</p>
</blockquote>
<h2 id="u4E0D_u8981_u8BD5_u56FE_u6EE5_u7528Cell_u7684_u91CD_u7528_u673A_u5236"><a href="#u4E0D_u8981_u8BD5_u56FE_u6EE5_u7528Cell_u7684_u91CD_u7528_u673A_u5236" class="headerlink" title="不要试图滥用Cell的重用机制"></a>不要试图滥用Cell的重用机制</h2><p>我知道TableView的重用机制让我们对于性能省了很多心思。然而有时候用的不正确其实会让程序消耗更多的性能。设想这么两个场景，一个是朋友圈的多图Cell，一个是Cell下方的点赞和评论视图，由于你将Cell从重用池中取出的时候，它所已经初始化好的ImageView数量和点赞评论视图和现在将要显示的这个数据源不一致，因此这时候你需要：</p>
<ol>
<li>还需要多少个ImageView就初始化多少个ImageView，不需要的就释放掉</li>
<li>点赞或者评论列表由于涉及到布局，可能整体都要重新初始化</li>
</ol>
<p>在滑动的过程中，视图的重新初始化是十分消耗性能的。尽量不要在layoutSubView中出现init的代码。因此如果你预先定义好10种Identifier，分别对应0到9个图片的情况的数据源，那么在相同数量图片的数据源之间复用的时候，就可以省略掉上面的第一步了。而点赞和评论列表则不可避免的需要重新布局，同样也是要减少初始化的操作。当然，对于Cell滑动的时候初始化的卡顿，我们也可以将点赞和评论的视图放在另外一个线程来绘制，然后再放回主线程来。</p>
<p>另外，Cell的复用和TableView的复用同样也是一个问题。可以说，大部分的复用其实都是用大量的ifelse来完成的。复用不是错误的，但是如果复杂度到了一定水平之后，就要慎重考虑复用的后果而不是每次都无脑的往上添砖加瓦了。</p>
<h2 id="u4E00_u4E9B_u5C0FTips_3F"><a href="#u4E00_u4E9B_u5C0FTips_3F" class="headerlink" title="一些小Tips?"></a>一些小Tips?</h2><blockquote>
<p>这些我总结出来的经验可能也许大概会和你们已有的一些经验发生冲突，我也希望能和大家有一些探讨。</p>
</blockquote>
<ol>
<li>属于Cell的逻辑最好写在Cell中，避免TableView所在的控制器臃肿冗长而复杂从而降低可维护性，适度聚合，适度耦合应该是最好的。例如Cell中的delegate就放在Cell中去处理，点击Cell中的图片需要跳转也放在Cell中去做，一些ImagePicker之类的控件也由Cell自己处理。控制器只负责数据的加载和外围事件的处理。这样可以控制每一个组件的规模，避免过分臃肿。</li>
<li>Cell的layout全部放在Cell中，在CellForRow中只做重用以及将数据传入Cell，让Cell自身去根据数据来layout，这样可以控制CellForRow这个方法的规模。一些新手很容易将大量的layout代码写在CellForRow中，导致一个方法就要滚好几屏，可读性极差。</li>
<li>不要到处写reloadData，你的队友们会把你炸了的。可以局部刷新的请用局部刷新。</li>
<li>复杂结构的Cell尽量不要用autolayout，由于autolayout会有一个视图依赖链，在Cell中更新一个约束会导致一系列视图的更新，当视图结构很复杂的时候，视图更新对性能的消耗就很大了。</li>
<li>在Cell中对CALayer的一些操作和效果，都会对性能有很大的影响。特别指出的是过多的圆角和阴影。</li>
</ol>
<h2 id="u66F4_u591A_3F"><a href="#u66F4_u591A_3F" class="headerlink" title="更多?"></a>更多?</h2><p>我暂时没有想到更多，如果读者有什么要批评吐槽我的就赶紧让我一起涨姿势吧！&gt; 3 &lt;</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h2><p>一直想写一篇UITableView使用经验的干货，因为TableView实在是太万能了，它帮你维护了Co]]>
    </summary>
    
      <category term="UITableView" scheme="http://sergiochan.github.io/tags/UITableView/"/>
    
      <category term="iOS菜鸟心得" scheme="http://sergiochan.github.io/categories/iOS%E8%8F%9C%E9%B8%9F%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我们只要把事实讲清楚就好了，至于下结论是他们的事。]]></title>
    <link href="http://sergiochan.github.io/2016/02/06/%E8%BF%87%E5%B9%B4/"/>
    <id>http://sergiochan.github.io/2016/02/06/过年/</id>
    <published>2016-02-06T12:53:46.000Z</published>
    <updated>2016-02-06T15:09:52.000Z</updated>
    <content type="html"><![CDATA[<p>过年回家果然是毫无效率可言。到处拜年，和各种长辈嘘寒问暖，见朋友，陪长辈。  </p>
<p>觉得自己现在的生活还是好脆弱，自己肩上的担子远比自己想象的更重。所错过和遗憾的大学头两年，也许并不是这么容易就能补回来的吧，那将成为我永远鞭策自己前进的一股伤痛。学是学了很多东西，但是确实转念一想，到现在也没有什么特别拿得出手的东西，现在静下心来把自己沉淀的东西开始整合成一个完整的项目了，然而又碰上过年，效率直线下跌，所以更加的烦闷。</p>
<p>年后的新一年的生活，我忽然感觉到很迷茫。显昆去真格实习来北京，Kevin公司搬到北京，我在北京到底何去何从，能够让我想要的家稳定和安宁一些，少一些风浪。2016年必定还会有更多的Hackathon等着我去挑战，我相信创意是源源不断的，能力也是一步步提升的，只要我坚持每一次都学习新技术，不论获奖与否都会是巨大的进步。所以我就更需要一个稳定的生活，来为我在各种时候的冲刺积蓄力量储备体力。</p>
<p>过年回来和父母坦白完，也狠下心来从今以后就连出国读书也要靠自己。我觉得我会为我没有在自己的人生中把自己砍得鲜血淋漓而在将来感到遗憾。我希望活的波澜壮阔，我希望哪怕是最后战死也要留下一段荡气回肠的故事，我希望我能和别人不一样，所以我继续往自己身上割出一道道伤口。从大四开始就已经完全经济独立，说实话那时候还比现在工作的我更有积蓄，毕竟在学校里，钱也没什么地方花，然而那时候也许是逆反，也许是不甘，我所努力完成的经济独立让我都为那时候的我感动了。然而现在，我有更严酷的未来要面对，真实的生活，社会，未来，这一切不再是学校那时候的水平了。我想过退缩，但是我还是不想让自己泯然众人，我还是想证明自己，证明自己能够将自己热爱的事情做到让世人都惊叹的时候。</p>
<p>所以我还是选择了，对自己更狠一点。希望一年后的自己不会辜负现在的我。就如我没有辜负一年前的我对我的期望一样。</p>
<p>听闻父母的一些朋友的孩子都准备结婚，家里买好房子办好喜酒什么的，又或者在父母身边留着，等着父母中年努力工作给他们置办未来的婚房，我忽然觉得这种人生不仅现实，而且渺小。也许和我相比，他们还是不知道高到哪里去了，毕竟人家在哪哪也有了房子，哪哪准备办喜酒，然而我还是觉得，论人生的渺小与否，在于最后留下的内容多少和精彩程度。</p>
<p>做自己最热爱的事情，并且尽全力做到最好，我觉得才是最精彩和最充实的人生，才是老年的时候，可以自豪的，欣慰的讲述给晚辈们听，告诉他们我的人生不曾遗憾过，也不曾空虚过。</p>
<p>为自己新的一年加个油吧。<br>希望自己做到最好，不去在乎别人对自己的眼光和评价。<br>很多事情，证明都摆在那里，无需我多说了。<br>别人相不相信，是他们的事情。</p>
<p>高中的时候，有一句话，从低谷的时候伴随着我走过来。<br><code>我们只要把事实讲清楚就好了，至于下结论是他们的事。</code></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>过年回家果然是毫无效率可言。到处拜年，和各种长辈嘘寒问暖，见朋友，陪长辈。  </p>
<p>觉得自己现在的生活还是好脆弱，自己肩上的担子远比自己想象的更重。所错过和遗憾的大学头两年，也许并不是这么容易就能补回来的吧，那将成为我永远鞭策自己前进的一股伤痛。学是学了很多东西，]]>
    </summary>
    
      <category term="闲言碎语" scheme="http://sergiochan.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[三件小事]]></title>
    <link href="http://sergiochan.github.io/2016/01/27/%E4%B8%89%E4%BB%B6%E5%B0%8F%E4%BA%8B/"/>
    <id>http://sergiochan.github.io/2016/01/27/三件小事/</id>
    <published>2016-01-27T13:36:18.000Z</published>
    <updated>2016-01-28T03:12:41.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u4E09_u4EF6_u5C0F_u4E8B"><a href="#u4E09_u4EF6_u5C0F_u4E8B" class="headerlink" title="三件小事"></a>三件小事</h1><p>事情是这样的。<br>江南皮革厂倒闭了。于是最近有这三件小事一直困扰着我。<br>一个是id和NSObject的解释，看过很多博客，但是却一直没有一个深刻的理解，现在醒悟过来觉得大概是看的那些博客本身就讲的含糊不清吧。所以我就用我最直白的语言和解释来说明一下我对于id和NSObject的一些小见解。一开始直接就是跟着代码写的，所以非常的直接。<br>第二个是weak和assign的小事，为什么delegate需要声明weak而不是assign。<br>第三个是关于这个<code>NS_DESIGNATED_INITIALIZER</code>宏的解释。</p>
<blockquote>
<p>示例工程在<a href="https://github.com/SergioChan/id-NSObjectDemo" target="_blank" rel="external">这里</a>。</p>
</blockquote>
<h2 id="id_2C_NSObject__u90A3_u4E9B_u4E8B"><a href="#id_2C_NSObject__u90A3_u4E9B_u4E8B" class="headerlink" title="id, NSObject 那些事"></a>id, NSObject 那些事</h2><p>这里讲的关于id和NSObject的内容，最好打开你的Xcode，打开demo工程，然后就能看到一系列编译的警告。跟着警告往下看你就会对于id和NSObject的区别更加的理解了。</p>
<p>这里你可以看到，test是一个指向UIImage对象的id指针，你可以向他发送length消息。<br>然而如果他不是一个对象指针，而是一个对象，那么你向他发送length消息的话，在编译的时候编译器会无法编译，原因在下面有提到。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">id test = <span class="comment">[<span class="comment">[UIImage alloc]</span> init]</span>;</span><br><span class="line"><span class="comment">[test length]</span>;</span><br><span class="line"></span><br><span class="line">NSObject *test1 = <span class="comment">[<span class="comment">[UIImage alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[test1 length]</span>;</span><br></pre></td></tr></table></figure>
<p>这里你可以看到，如果引入了TestObject的头文件，对于任意id类型的对象指针，你就可以向他发送TestObject能够响应的消息了。<br>无论这个id类型指针指向的对象是不是TestObject类型，编译器并不关心这个，也无法知道。<br>然而对于NSObject，他仍然不能响应这个fuck方法，因为向一个对象发送消息的时候，编译器会在对象声明类型的方法表中去判断这个对象是否能够响应这个消息，而不是根据实际分配的对象类型。</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">id test3 = <span class="comment">[<span class="comment">[UIImage alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[test3 fuck]</span>;</span><br><span class="line"></span><br><span class="line">NSObject *test2 = <span class="comment">[<span class="comment">[TestObject alloc]</span>init]</span>;</span><br><span class="line"><span class="comment">[test2 fuck]</span>;</span><br></pre></td></tr></table></figure>
<p>所以其实NSObject很少手动声明，如果要声明具体的对象，则最好声明具体的类型，或者id动态类型。<br>id之所以为动态类型，在于它所指向的对象类型是在运行时才确定的，因此使用起来更加的方便。<br>NSObject 只能响应自己的一些简单的方法，例如 copy，hash之类。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">test</span>2 <span class="built_in">hash</span>];</span><br></pre></td></tr></table></figure>
<p>下面解释了为什么delegate要用id声明而不是用NSObject</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="keyword">id</span>&lt;TestDelegate&gt; delegate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">weak</span>) <span class="built_in">NSObject</span>&lt;TestDelegate&gt; *delegate;</span><br></pre></td></tr></table></figure>
<p>大部分delegate在实现的时候都需要像下面这个来调用，根据上文所说，因为delegate的方法表其实是运行时才能知道的，在编译时编译器是无法识别的，所以这种调用方式也就不能成立，因此delegate要用第一种id的声明方式来声明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NSObject *<span class="built_in">test</span>4 = [[TestObject alloc]init];</span><br><span class="line"><span class="keyword">if</span>([<span class="built_in">test</span>4 respondsToSelector:@selector(fuck)])</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">test</span>4 fuck];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">id <span class="built_in">test</span>5 = [[TestObject alloc]init];</span><br><span class="line"><span class="keyword">if</span>([<span class="built_in">test</span>5 respondsToSelector:@selector(fuck)])</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">test</span>5 fuck];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然如果id所指向的对象在运行时无法响应fuck方法，运行时就会报错。<br>可以这么说吧： <strong>NSObject声明的对象类型在编译时确定，id声明的对象类型在运行时确定</strong>，因此在消息发送上会有一些区别。</p>
<h2 id="weak_2C_assign__u90A3_u4E9B_u4E8B"><a href="#weak_2C_assign__u90A3_u4E9B_u4E8B" class="headerlink" title="weak, assign 那些事"></a>weak, assign 那些事</h2><p>这个问题起源于这两种声明delegate的方式：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>  &lt;fuckDelegate&gt; delegate; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span>  &lt;fuckDelegate&gt; delegate;</span><br></pre></td></tr></table></figure>
<p>首先第一种声明方式在我们的日常使用中十分的常见，可能都已经成为一种习惯了。但是例如已经被废弃的 <code>@property(nonatomic, assign) id&lt; UISearchDisplayDelegate &gt; delegate</code>，虽然在iOS8之后被废弃，然而它说明delegate也可以用第二种声明方式。</p>
<p>区别就在于weak和assign声明的属性虽然都是不会引起引用计数的增加，但是还是有很大不同。<a href="http://www.cocoachina.com/ios/20150605/11990.html" target="_blank" rel="external">weak的实现</a>决定了在属性的主人释放的时候，weak指针所对应的对象也会一起被释放，然而assign不会，因此这里有产生一个野delegate指针的风险。除非是在MRC的环境下，手动对delegate置为nil。这会需要额外的操作，因此后来系统的实现渐渐的也转向weak了。</p>
<p>参考<a href="http://stackoverflow.com/questions/9428500/whats-the-difference-between-weak-and-assign-in-delegate-property-declaratio" target="_blank" rel="external">这里</a>。</p>
<h2 id="NS_DESIGNATED_INITIALIZER"><a href="#NS_DESIGNATED_INITIALIZER" class="headerlink" title="NS_DESIGNATED_INITIALIZER"></a>NS_DESIGNATED_INITIALIZER</h2><p>第一次看到这个的时候，心里想的是 “WTF 这是什么鬼”。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line"><span class="pp">-<span class="params">(instancetype)</span>initWithName:<span class="params">(<span class="variable">NSString</span> *)</span>name NS_DESIGNATED_INITIALIZER;</span><br><span class="line">-<span class="params">(instancetype)</span>init;</span></span><br></pre></td></tr></table></figure>
<p>这时候看看Swift就明白了 =。= 这是objc为了配合Swift的特性而诞生的一个附加宏。Swift中有designated和convenience两种初始化方法，它要求我们初始化出来的实例对象尽量是属性完整的，即使使用了convenience的初始化方法，也会要求在这个初始化方法中调用同类的designated的初始化方法完成完整的初始化。</p>
<p>像这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">- (instancetype)<span class="keyword">init</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithName:@<span class="string">"fuck"</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithName:(<span class="type">NSString</span> *)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以这只是一个Swift的特性的objc版本，也是为了更好的和Swift配合开发而加上的。</p>
<p>参考<a href="http://stackoverflow.com/questions/26185239/ios-designated-initializers-using-ns-designated-initializer" target="_blank" rel="external">这里</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u4E09_u4EF6_u5C0F_u4E8B"><a href="#u4E09_u4EF6_u5C0F_u4E8B" class="headerlink" title="三件小事"></a>三件小事</h1><p>事情是这样的。<br>江南皮革厂倒闭了。于是最近]]>
    </summary>
    
      <category term="NSObject" scheme="http://sergiochan.github.io/tags/NSObject/"/>
    
      <category term="NS_DESIGNATED_INITIALIZER" scheme="http://sergiochan.github.io/tags/NS-DESIGNATED-INITIALIZER/"/>
    
      <category term="assign" scheme="http://sergiochan.github.io/tags/assign/"/>
    
      <category term="id" scheme="http://sergiochan.github.io/tags/id/"/>
    
      <category term="weak" scheme="http://sergiochan.github.io/tags/weak/"/>
    
      <category term="iOS菜鸟心得" scheme="http://sergiochan.github.io/categories/iOS%E8%8F%9C%E9%B8%9F%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[无题-20160120]]></title>
    <link href="http://sergiochan.github.io/2016/01/20/%E6%97%A0%E9%A2%98-20160120/"/>
    <id>http://sergiochan.github.io/2016/01/20/无题-20160120/</id>
    <published>2016-01-20T09:05:04.000Z</published>
    <updated>2016-01-20T09:17:22.000Z</updated>
    <content type="html"><![CDATA[<p>忽然发现拿再多第一，再多人认可你，这个世界还是那么大，还是总会有那么些人，无法满足他们那种居高临下，那种自以为占据所有主动地屌逼感，反而会让他们更加的想要刁难你和鄙视你。如果不是一路人的话，就不会是相互吸引，而只是相互排斥。</p>
<p>最近各种遇见和感受到。<br>But whatever, 你走你的路，有那么多人支持你，再说了，未来你想要的世界是依靠和你相似，相吸引的这群人一起来创造的，而且你也不断在证明这一点，那么那些所谓的其他人，是吧。</p>
<p>最近准备重新开始读三国演义。觉得团队管理和自己未来的处世方式在里面都有很多可以借鉴的。</p>
<p>例如 纵使你有十万大军，没有一个赵子龙，你一样被人家单骑救阿斗。</p>
<p>很感谢，很感激，自己一路走来，凝聚在我周围或者对我特别在乎，特别认可的基友们。我和你们一起去创造了太多不可能的事情。<br>确实，拿第一第二第三，又有毛用，即使把全国全世界的Hackathon第一都拿遍了，该鄙视我的人还是鄙视我，该认可我的人还是认可我，这些并不能改变什么，相反，所有的事情，我能够去享受每一次的过程，和志同道合的这些基友们一起为了同一个目标热爱和奋斗，这才是我为什么走下去的原因。  </p>
<p>那些鄙视我，不珍惜我的人，请等着被打脸吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>忽然发现拿再多第一，再多人认可你，这个世界还是那么大，还是总会有那么些人，无法满足他们那种居高临下，那种自以为占据所有主动地屌逼感，反而会让他们更加的想要刁难你和鄙视你。如果不是一路人的话，就不会是相互吸引，而只是相互排斥。</p>
<p>最近各种遇见和感受到。<br>Bu]]>
    </summary>
    
      <category term="闲言碎语" scheme="http://sergiochan.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[2015]]></title>
    <link href="http://sergiochan.github.io/2015/12/21/2015/"/>
    <id>http://sergiochan.github.io/2015/12/21/2015/</id>
    <published>2015-12-21T12:13:17.000Z</published>
    <updated>2015-12-29T14:03:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="u770B_u770B_u53BB_u5E74_u5E95_u7ED9_u81EA_u5DF1_u5B9A_u4E0B_u7684_u76EE_u6807"><a href="#u770B_u770B_u53BB_u5E74_u5E95_u7ED9_u81EA_u5DF1_u5B9A_u4E0B_u7684_u76EE_u6807" class="headerlink" title="看看去年底给自己定下的目标"></a>看看去年底给自己定下的目标</h1><p>还是觉得自己的2015年过的蛮有意义的。回头看了看去年底写的对2015年的展望，发现去年对自己的展望基本在今年8月份左右就已经实现完了，反而是在九月之后经历了又一次巨大的跌宕起伏，有了很多意外的收获。一年过得实在是太充实……</p>
<h1 id="u4E0D_u5F97_u4E0D_u8BF4_u6211_u7684_u5B9E_u4E60_u548C_u5DE5_u4F5C_u7ECF_u5386"><a href="#u4E0D_u5F97_u4E0D_u8BF4_u6211_u7684_u5B9E_u4E60_u548C_u5DE5_u4F5C_u7ECF_u5386" class="headerlink" title="不得不说我的实习和工作经历"></a>不得不说我的实习和工作经历</h1><p>首先，我是在tata度过了从大四到毕业后的十个月，这里面的感情真的没法言说，这是我第一家稳定下来的公司，也是找到了归属感的团队。在公司里认识了一大帮子朋友，学了python，搭了一套newsfeed系统，尝试着做了一套TCP服务器间内部调用的框架。习惯了Linux服务器，习惯了shell，习惯了vim，在后端技能方面长进了太多。掌握了Redis和Mongo，学会了NoSQL的设计思想，当然部署和操作什么的都是简单的部分了。准备有空读Redis源码，大致看了一下感觉还好……同时也有了一定处理并发和较大规模系统的能力，在信息流系统并发较大的时候有了一定处理经验，这是我还在学校的时候最宝贵的经验，也是我去年底给自己定下的目标里写到的。对于一个还在大四的学生，有过处理百万级用户量的数据库和相当高的并发量的后端系统的经验真的是十分宝贵的。并且从陈健那儿学到了很多架构经验，很宝贵，这些架构思想极大的提高了我的系统设计能力。<br>遇到了老曹，很耐心的CTO，对我也十分的器重。谈不上人生导师，但对我的职业生涯，和对自己的定位都起了很大的影响，我开始明白自己应该怎么成长了，也懂得对自己做更好的职业生涯规划。同时整个全栈的知识体系和技能体系也变得丰富起来。<br>九月由于一些团队的原因，想要找个更高的平台提升自己，所以当时先是傻逼的在拉钩上投了微博小米和百度。可能在那个时候，还不是特别有信心直接就找内推，而且那个时候正好赶上秋招，机会还算蛮多的，于是打算自己先试试。第一个去的是微博。我在微博坐了半个小时没有人理我，做了一个小时的题也没有人给我倒杯水，二面的面试官也是急匆匆的就问完走了，并且在面试的过程中对我表示了极其明显的鄙视和轻蔑。虽然我在后来拉钩的评价上给了一颗星的差评，但是这段经历对我下半年最后几个月的转变是非常重要的。我开始明白我并不能要求所有人都对我满意，但是我至少还是得被一部分人认可，这样才不会说明我的所谓能力其实纯属扯淡。当我受到这样的对待的时候，虽然很大一部分是因为我是拉钩来的社招，并且他们甚至没有重视我刚毕业这个事实，而是认为我是刚跳槽的社会人员，但是我还是认为很大一部分原因出在自己的身上。回去之后，我开始更注重在工作中对自己能力的积累，我自己研究了runtime和runloop这些运行机制之后，发现天天写业务逻辑，和不懂技术瞎扯淡的产品经理配合简直就是对自己职业生涯的浪费和埋没，我被所谓需求所蒙蔽，根本难以接触到技术的真谛，我明白我需要做出一些改变了。所以才有了后来的波澜壮阔的历程。<br>第二个去的是百度。说实话这是我对百度印象最好的一次。然而最后的结局十分的无奈和可惜，百度砸在了O2O上，全面停止了社招，于是我阴差阳错的被自己误过了发出offer的时间点，错过了去百度的机会。但是百度的那次面试，前两面的面试官，以及最后三面电话里的负责人，都给了我非常好的印象，感觉真的可能是一个适合我的团队。并且二面的小哥，是我遇见的第一个会在面试的过程中打开我的博客和Github主页逐个问我并和我聊天的面试官。<br>不过还是那句话，上帝在给你关上一扇门的时候，总会给你打开另一扇窗户。所以当百度确认无法争取到offer之后，我当时满脑子只有一个想法，10月份的segmentfault Hackathon一定要好好玩，好好地和小萌配合一次，认真地，尽力的努力一次，去追求自己热爱和快乐的事情。  </p>
<blockquote>
<p>写下这些文字的时候，我正在踏上再次去寻找小萌的旅途。圣诞节将在杭州的西湖边度过。这一次，我想，既然我们已经找到了自己真正喜欢的事情，就一定要努力地奋斗下去。再不留遗憾。</p>
</blockquote>
<h1 id="Hackathoner"><a href="#Hackathoner" class="headerlink" title="Hackathoner"></a>Hackathoner</h1><p>2015年另一个意外就是接触到了Hackathon，并且与之陷入爱河。<br>第一次参加的是北航的Dorahacks Hackathon，忘记那次的报名信息是从哪儿看的了，好像是朋友圈谁转发的，于是就报名了，并且拉上了杨大神和邓晗。虽然在那次参赛之前我根本对Hackathon没有什么了解，但是也幸运的拿了第一，这次经历使我逐渐成为了一个狂热爱好Hackathon的Geek。后来参加了大众中国的Hackathon，和一堆MBA博士们一起比赛，被虐的体无完肤，才慢慢明白Hackathon不是自己想象中的那么单纯。第三次是十月份的SegmentFault Hackathon，将我从错过百度的阴影中拯救出来，接触到了非常纯粹的Hackathon。  </p>
<blockquote>
<p>Hackathon 这部分可以参考我的<a href="http://sergiochan.xyz/2015/12/19/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Hackathon%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank" rel="external">这篇博客</a>。</p>
</blockquote>
<h1 id="iOS_u5F00_u53D1"><a href="#iOS_u5F00_u53D1" class="headerlink" title="iOS开发"></a>iOS开发</h1><p>今年九月就是正式入坑iOS一周年，五月份把给公司产品写的第一个控件开源，来到了Github这个全球最大的男性社区，开始搞基。七月份开始写几个独立应用，除了密码管理的上架了，其他都夭折了，感觉写独立应用不是在开源社区里的成长方式，并且写独立应用对于自己的综合能力，包括设计,审美和创意之类的也都有一定要求，也许现在的我去写才会有一些感觉吧。后来总结出来的是，在开源社区的成长，要么写一个很好用的轮子，要么模仿一个很好看的应用，我肯定不想做后者……在公司里写业务写的就够累了，还花时间去模仿人家的客户端干嘛。所以也是纠结了好一段时间没东西写，一直到了九月份，还在写一些无关紧要的项目。第一个比较完整的项目就是开源了公司产品里头基于protobuf的模仿微信的网络请求框架。同时写了一个python的解数独的程序和基于TCP连接的服务器内部调用的框架。直到10月底才开始慢慢找到方向，从第一个试水的TableViewCell开始，逐渐写了一些或者好看的或者好用的或者有创意的轮子，一直到现在，也总共收获了一千多的star了，期间认识了无数开源社区里的基友，感慨时间匆匆，自己没有早点入坑。接下去还是会尽力把这些之前项目所积累的经验和开源的经验结合起来，创造更多更好用的交互模块。<br>一开始写一些开源的时候，DQ让我发到微博去获得一些关注，同时可以找到更多的人交流，于是我就尝试着进入了微博。没想到写的一些动效实现挺受欢迎的，于是就有了更多做下去和热爱的动力。我也在这个过程中认识了Martin老湿和XerLee大神，和一些比较有名的交互设计师有了更多的交流，实现了一些这些设计师做的设计，而且又有小萌和翻译组的一些小伙伴支持，于是就有了发起组织的想法。再加上马老湿又比较勤奋好学的开始写Swift并且尝试自己实现自己做的动效设计，所以就很快的搞在了一起，交流代码经验什么的。所以就慢慢步入了开源的正轨，成立了开源组，不过开头做了一点东西之后到年底了，小萌期末考，我们都忙着工作，所以有半个月对于开源组的贡献很少，毕竟每次从设计，到实现，最后产出一个完整的框架或者控件，然后还要整理出一篇通俗易懂，讲解合理生动的分享博文都是一件特别花时间和精力的事情，所以开源的工作实际上比想象中要复杂得多。</p>
<h1 id="SwiftGG"><a href="#SwiftGG" class="headerlink" title="SwiftGG"></a>SwiftGG</h1><p>正式加入swiftGG翻译组，从翻译swift官方指南，到成立翻译组，开始翻译。加入SwiftGG这个逗比组是2015年最正确的选择之一。在组里接触了Swift，业余时间开始一点点的自学，虽然基本还是没有怎么使用。最主要的还是接触了一大帮翻译组的成员，以及接触了Swift中文大会，遇见和认识了来自全国各地天南海北的基友们，忽然有了好多基友可以交流技术问题，交流代码，交流开源，这种感觉真的是超级幸福。<br>明年1月10日的大会，感觉可以和天南海北的开发者们好好面基了😂</p>
<h1 id="u535A_u5BA2"><a href="#u535A_u5BA2" class="headerlink" title="博客"></a>博客</h1><p>开始稳定写博客，大概一个月一篇，速度有点慢，但是工作也忙。<br>比较注重博客质量，因为只有原创的好博客才能吸引一些读者吧，虽然最后确实有一些人关注我的博客 :-P<br>博客的历程比较曲折，一开始是在香港的虚拟主机里搭的Wordpress，用了半年多，自从七八月份开始莫名其妙被俄罗斯和乌克兰的黑客攻击，我的流量就没下来过 -。- 所以开始着手换到了Github上，迁移过程中丢弃了一些文章，所以现在的博客文章看起来并不多。后来刚迁移到Github之后，发生了惨无人道的水淹事件，我不小心把一杯水倒在了刚买的电脑上，导致尚未更新的Github的博客源文件丢失，后来过了两周才换了新电脑，这个过程中我的博客就处于了停滞的状态。直到最近才终于又稳定下来，继续维护和优化属于自己的个人站点和技术博客。<br>而且原域名已经被我弃用了，换成了现在的sergiochan.xyz。</p>
<h1 id="u5BF9_u81EA_u5DF1_u660E_u5E74_u7684_u671F_u671B"><a href="#u5BF9_u81EA_u5DF1_u660E_u5E74_u7684_u671F_u671B" class="headerlink" title="对自己明年的期望"></a>对自己明年的期望</h1><p>我明白自己的职业生涯到了最关键的冲刺期，在这个阶段里，我的经验，能力，眼界和社交圈都会飞速的膨胀，这一年从大学中脱离出来的经历已经让我明白了我之前在大学里浪费的两年多时光是多么的遗憾，但是幸运的是从2015年开始我走上了一条我到现在还觉得是正确的道路。<br>明年首先的愿望，或者是奢望，就是能够通过更多的Hackathon和开源，认识更多和我志同道合的朋友们，继续和小萌一起结对编程下去。希望能够运气好点再捞几个奖牌回来，前几天在2015年的收官之作中，又拿了一个第一，为我和小萌2015年的成长划上了一个完美的句号。<br>第二个愿望，就是好好把一起动画开源组给做起来。最近年末这段时间，由于自己刚搬家，比赛，大会什么的事情，马老师那里又有很多要忙的，小萌要考试，所以开源组一直没有产出新的好东西。但是等到新的一年开始之后，这些事情都要走到正轨上来了。我也希望这次面基大会认识的这一大帮国内走在前列的开发者，以后能够踊跃的交流，一起来把开源做好。<br>第三个期望，还是好好过日子吧。好好过着现在这样的稳定的小日子，这大概是一切以上所述事情的根基了吧。当感情开始漂泊，生活开始流浪的时候，事业就没有了稳定的基础。所以，珍惜眼前的一切，才是最重要的。</p>
<p>当然，我明白，这些期望，最后，肯定远不及明年的收获。对于我来说，只要这样疯狂的向前冲，从中体会到乐趣和自己所热爱的事情，我想，我能走多远，只有最后才会明白吧。  </p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u770B_u770B_u53BB_u5E74_u5E95_u7ED9_u81EA_u5DF1_u5B9A_u4E0B_u7684_u76EE_u6807"><a href="#u770B_u770B_u53BB_u5E74_u5E95_u7ED9_u81EA_u]]>
    </summary>
    
      <category term="闲言碎语" scheme="http://sergiochan.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[语]]></title>
    <link href="http://sergiochan.github.io/2015/12/21/%E8%AF%AD/"/>
    <id>http://sergiochan.github.io/2015/12/21/语/</id>
    <published>2015-12-21T03:52:36.000Z</published>
    <updated>2015-12-21T03:54:08.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>对自己降低期望是对自己最好的宽恕。<br>有时候期望太高反而没有办法有所突破吧。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>对自己降低期望是对自己最好的宽恕。<br>有时候期望太高反而没有办法有所突破吧。</p>
</blockquote>
]]>
    </summary>
    
      <category term="闲言碎语" scheme="http://sergiochan.github.io/categories/%E9%97%B2%E8%A8%80%E7%A2%8E%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[谈谈我对Hackathon的理解]]></title>
    <link href="http://sergiochan.github.io/2015/12/19/%E8%B0%88%E8%B0%88%E6%88%91%E5%AF%B9Hackathon%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://sergiochan.github.io/2015/12/19/谈谈我对Hackathon的理解/</id>
    <published>2015-12-19T01:06:02.000Z</published>
    <updated>2015-12-19T01:08:13.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Hackathon__u662F_u4EC0_u4E48"><a href="#Hackathon__u662F_u4EC0_u4E48" class="headerlink" title="Hackathon 是什么"></a>Hackathon 是什么</h1><p>我们先要理解Hackathon这个词的起源。它起源于1999年，词语本身来自于Hack和Marathon的组合，意思就是一群程序员或者软件工程师相聚在一起，像马拉松一样不停的从起点跑到终点进行比赛。由于大部分Hackathon都是现场命题制，这就意味着所有程序员在一开始都是站在同一起跑线上的，所以Hackathon成为了每一个热爱挑战的程序员能够挑战自身各方面能力的机会。</p>
<p>没错。我说的是，挑战。就如覃超大哥在SegmentFault的Hackathon开始的时候说的那样，hack精神就是Facebook最为推崇的理念，它的很多产品创新和突破都是来自于内部的Hackathon上迸发的灵感。所以应该不难理解，Hackathon的精神在于挑战自我和固有的事物、想法，从而去创造新的事物和新的想法。</p>
<h1 id="u6211_u7684Hackathon_u7ECF_u5386"><a href="#u6211_u7684Hackathon_u7ECF_u5386" class="headerlink" title="我的Hackathon经历"></a>我的Hackathon经历</h1><p>先说说我的Hackathon经历吧。在接触Hackathon之前，我接触过很多创业团队，见过很多新的想法，但大部分都因为时间问题或者进度问题一拖再拖，亦或是这些想法并没有特别的打破人们固有的一些想法和思维模式。而我就已经乐衷于开拓自己的思维模式和范围，去接触更大的互联网世界。</p>
<p>从创业和各种项目一路走来，我对软件工程的热爱逐渐在团队合作中被我自己培养了起来。对我来说，做一件事情，最重要的当然是这件事情是否有趣，是否值得我去热爱，其次就是能够和小伙伴一起去做这件事情，还记得两年前我刚开始走上这条道路的时候，我写到，“携两三靠谱好基友，凭一腔热血，青春年少，有什么做不到的。年轻就该气盛，才不负年华”。</p>
<p>于是，当我第一次和小伙伴一起接触到Hackathon的时候，我就陷入了无比的狂热中。那是Dorahacks在北航举办的一次Hackathon，由于没有经验，我们也没有熬夜，只是晚上在QQ上相约一起写了一部分，第二天早上早早到地方开始调bug。一开始我们也通过头脑风暴想出了很多奇怪的创意，但是都被否定了，最后思宇在散步的时候想出了网页弹幕这个鬼点子。于是那也开启了我们每次Hackathon都一定会有的弹幕模式……其实写一个网页弹幕的Chrome插件花不了多少时间，加上leancloud即时通信和存储的集成，我们总共也没花几个小时，就将一个差不多通过了测试的版本放上台展示了。</p>
<p>展示的时候，我扯了一大堆弹幕的起源和95后新兴人类的社交模式，扯了我从创业以来了解的各种互联网现状，然后啪的一展示，小伙伴们啪啪啪打了一堆弹幕上去，正好浏览的网页又特别想让人吐槽，所以大家都笑了，我们顺理成章拿了第一。</p>
<p>后来我就总结出这么个道理，Hackathon，展示也是相当关键的一环，你要么让观众大笑，要么让观众大惊，如果观众一点反应都没有，那你就基本没有希望了。所以Hackathon，一定意义上并不是完全的在挑战一个人的思维能力，代码能力，团队合作能力之类的东西，更是在挑战和检验一个人的表达能力，简单地说，一个人的气场。对于一般的程序员来说，可能根本没有意识到在平时所谓气场和表达能力有什么重要性，但是，这也就意味着一个程序员将会永远在这种局限性之下成长。</p>
<p>以上总结同样适用于我们接下来参加的一次大众中国的Hackathon。虽然这就是我将要说的商业大赛，但是最后拿了第一的团队，对于展示的把握相当的成熟，让我也学到了很多。我们什么奖也没有获得，但是我们脑洞大开的想让车与车之间通过弹幕的方式在公路上连接在一起。不知道为什么，也许我们和其他MBA或者博士们参加Hackathon的动机不一样吧，所以我们受到了相当的关注，这也让我感觉特别不自在和恼火。这本来就是大人们的一个游戏，他们只是对我们感到好奇罢了。</p>
<p>挂羊头卖狗肉，是我对于很多这样的所谓Hackathon的商业创新大赛和外包大赛的总结。也许是各种企业主和策划方都觉得通过传统的比赛模式没有办法吸引到新时代的人才了，所以总是各种效仿，挂上Hackathon的名号。有一些比赛评委根本不看技术而看商业模式和商业分析，来自企业的一些Marketing的评委关注点是在如何让他们的企业赚更多的钱上，对于技术的创新性和效果并没有那么接受；而有一些比赛的评委对于自己出的题目已经有了相当明确的答案，却只是希望参加比赛的hacker能够按照他的期望把一个东西的原型做出来。</p>
<p>是的，如果你想用广义的Hackathon定义来理解，你也许可以将他们也包含到Hackathon中，但是不可否认的是，这些比赛形式的本质是传统的，是抑制技术创新的。真正的Hackathon，应该是基于技术的创新和理念的创新，去解决一个实际的问题，从而让世界变得更美好。</p>
<p>上周末的TC Hackathon，我想说我们最后退出了。在讨论了很久之后，对于某个企业提出的冰柜的题目，我们虽然觉得有很多能创新的点，但是当评委介绍完整个任务之后，我其实已经觉得没有多大希望了——评委对于项目有着明确的要求，甚至可以说他们应该已经花费了一些人力在这个项目上。整个题目是这个企业之前就已经提出的一个创业点，他们不希望自己投入研发成本去做这件事，而希望创业团队来帮他们实现。当没有什么好的创业团队来做这件事的时候，他们就把这件事情扔到一个Hackathon上，可以说，那些可怜的奖金如果换做外包的形式的话，数额只够一个人的所得。用廉价的奖金换来一个优质的外包方案，我相信对于每个企业都是一种好的选择。我也认识一些传统行业的人，他们告诉我，通过将项目外包给学校或者在学校内组织比赛的形式帮助他们完成一个项目的开发是他们很经常采用的手段。这个道理我想很多人都明白，但是我不希望外包比赛非得套上Hackathon的头套，玷污我心里对于技术创新的向往和渴望。</p>
<p>最好的一次Hackathon是两周前的SegmentFault Hackathon。由于它本身是个开发者社区，而且这个Hackathon已经相当成熟，由他们自己举办，因此来自外界的干扰和污染特别小，评委也是来自于一线的新兴创业团队，并且都是一些注重技术和技术分享的公司。在这个比赛中，除了少量出现的偷偷用成品参加比赛的行为，包括零食，饮料的供应，都比TC的那次丰富和完善许多。而且采用的是现场公布题目的形式，题目的点也相当容易发散，不会提各种需求，这才让我感觉真真正正能出一些好东西。说实话，如果在Hackathon上还提一点两点三点好几点需求，那我就真的觉得和我平时做咨询，帮团队分析产品，做基础技术架构设计没有区别了。</p>
<p>也许只有SegmentFault的Hackathon才配得上年轻开发者的节日1024吧。</p>
<h1 id="Hackathon_u9700_u8981_u7684_u6280_u80FD"><a href="#Hackathon_u9700_u8981_u7684_u6280_u80FD" class="headerlink" title="Hackathon需要的技能"></a>Hackathon需要的技能</h1><p>对于我来说，我最害怕的就是止步不前，更害怕的是自己甘愿和其他90%的人一样陷于固有的事物和思维模式。我相信每一个接受过良好本科教育的大学毕业生在许多所谓的基础方式上都有着良好的基础，我们在校园里已经接受了足够的通识教育和专业基础教育，真正让每个人能够变得不同或者更好的，是在这个基础之上的思维模式。而Hackathon，既是对你的思维模式的磨炼，也是一种考验。</p>
<p>参加Hackathon，你需要首先对这个比赛有足够的判断能力，他到底是个商业大赛，还是外包大赛，还是真的Hackathon？对于不同类型的“Hackathon”，你需要做不同的准备，虽然当你发现是前两者之后你可能已经对它失去兴趣了。下面是你需要的一些技能。</p>
<h2 id="u4F60_u9700_u8981_u51DD_u805A_u4E00_u4E2A_u56E2_u961F_u3002"><a href="#u4F60_u9700_u8981_u51DD_u805A_u4E00_u4E2A_u56E2_u961F_u3002" class="headerlink" title="你需要凝聚一个团队。"></a>你需要凝聚一个团队。</h2><p>对于团队的凝聚力更大程度应该是通过事情，而不仅仅是所谓的个人魅力。事情有趣，事情酷炫，事情实实在在的解决问题，我想每一个有激情的人都会很主动的投入进来。所以你需要想清楚要做的事情应该是什么样的，是实际的，还是超出自己想象的，对做的事情需要有一个方向的把控，这才能够凝聚起一个团队。我始终坚信，共同的热爱才是团队一致向前的最好动力。</p>
<h2 id="u4F60_u9700_u8981_u6311_u9009_u4F60_u7684_u56E2_u961F_u3002"><a href="#u4F60_u9700_u8981_u6311_u9009_u4F60_u7684_u56E2_u961F_u3002" class="headerlink" title="你需要挑选你的团队。"></a>你需要挑选你的团队。</h2><p>Hackathon不是刷上机题，你不是一个人在战斗。所以团队是最重要的部分。首先你需要保证你自己的技术栈足够宽，这里我说的不是什么web全栈框架，我说的技术栈是从前端，客户端，后端，数据库，服务器到建模，动画，设计，客户端的游戏开发，甚至还有视频制作这种技术如果最好都需要覆盖到。当然，对于一个人来说做到这些太困难了，所以这也就是你需要团队的原因。如果是偏商业大赛，即有比较明确的商业赞助和商业评委的参与，那么你还需要一到两个Marketing的小伙伴加入；如果是偏外包大赛，甚至纯技术的团队都可以胜任，但是有一个产品/交互会好很多；如果是纯Hackathon，组一个纯产品的小伙伴就没有特别大的意义了，那个时候，人人都可以是产品经理！</p>
<p>团队人数方面，大部分Hackathon都限制在3~5人得范围内，最佳组合应该是能满足上述要求的4人组合。竞争力足够和5人团队匹敌，而5人团队也容易出现分歧，从而拖延本来就赶的进度。每一个决策都要尽量让每个队员都特别接受，并且有激情去做，因为Hackathon是在短时间内对每个人的精力和毅力的极大挑战，如果没有激情，那么你就会因为队员的疲惫而失去原本属于他的那份时间。</p>
<h2 id="u4F60_u9700_u8981_u5B66_u4F1A_u4E0D_u4E00_u6837_u7684_u5934_u8111_u98CE_u66B4_u3002"><a href="#u4F60_u9700_u8981_u5B66_u4F1A_u4E0D_u4E00_u6837_u7684_u5934_u8111_u98CE_u66B4_u3002" class="headerlink" title="你需要学会不一样的头脑风暴。"></a>你需要学会不一样的头脑风暴。</h2><p>这里的意思是如果你用正常的头脑风暴方式去思考，那么别人会和你做着同样的事情，到达同一个点，并且开始做同一个想法。这直接就宣告你的努力白费了。所以，你需要学会不一样的头脑风暴方式，不是从题目里的字眼发散，而是尝试着跳出来，从各处散乱的灵感里找到几个和题目接近的主题，再从那些主题中发散。记住，你能想到的东西，90%以上别人都会想到，所以我们要做的是去想别人想不到的那些想法。</p>
<h2 id="u70ED_u7231_u3002"><a href="#u70ED_u7231_u3002" class="headerlink" title="热爱。"></a>热爱。</h2><p>没有什么好说坚持和毅力什么的。那些都没有办法让你做到最好。只有热爱，像乔布斯说的那样，只有热爱能够让你真正把一件事情做好。所以在Hackathon的时候也一样，记住，一定要找到你热爱的东西，然后去完成它。如果找不到，就继续找，当然如果实在找不到，你可以选择随便找一个刚刚想出来的点子去实现。我相信4个人的思维火花碰撞，如果Hackathon足够纯净，你不可能找不到热爱的东西的。在Hackathon中，最切忌切忌的，就是凑合，为了做项目而去做项目。</p>
<h2 id="u5C55_u793A_u7684_u65F6_u5019_uFF0C_u8C26_u865A_uFF0C_u4F46_u662F_u8BA9_u522B_u4EBA_u611F_u53D7_u3002"><a href="#u5C55_u793A_u7684_u65F6_u5019_uFF0C_u8C26_u865A_uFF0C_u4F46_u662F_u8BA9_u522B_u4EBA_u611F_u53D7_u3002" class="headerlink" title="展示的时候，谦虚，但是让别人感受。"></a>展示的时候，谦虚，但是让别人感受。</h2><p>展示也是相当重要的一部分，如我上文所提。当你在最后的展示的时候，你需要让所有人都能感受到你的热爱，感受到你们的想法和你们所实现的东西的激情，这时候就需要你的表达能力和感染力了。在台上不要害怕，保持谦虚是一种很好的驱赶恐慌感的方式。简单明了的让大家了解你的想法，并且通过demo的演示让大家感受到你的热爱。好的东西，才更需要一种好的途径进入每一个观众的内心。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Hackathon__u662F_u4EC0_u4E48"><a href="#Hackathon__u662F_u4EC0_u4E48" class="headerlink" title="Hackathon 是什么"></a>Hackathon 是什么</h1]]>
    </summary>
    
      <category term="Hackathon" scheme="http://sergiochan.github.io/tags/Hackathon/"/>
    
      <category term="Hacker" scheme="http://sergiochan.github.io/categories/Hacker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[runloop初窥]]></title>
    <link href="http://sergiochan.github.io/2015/10/22/runloop%E5%88%9D%E7%AA%A5/"/>
    <id>http://sergiochan.github.io/2015/10/22/runloop初窥/</id>
    <published>2015-10-22T11:36:23.000Z</published>
    <updated>2015-12-18T13:13:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5148_u6765_u8BF4_u4E00_u4E2A_u5F88_u7B80_u5355_u7684_u5B9E_u4F8B"><a href="#u5148_u6765_u8BF4_u4E00_u4E2A_u5F88_u7B80_u5355_u7684_u5B9E_u4F8B" class="headerlink" title="先来说一个很简单的实例"></a>先来说一个很简单的实例</h2><p>在scrollView中添加一个timer来刷新视图的时候，如果只是简单的声明</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">self.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1.0</span>f <span class="string">target:</span>self <span class="string">selector:</span><span class="annotation">@selector</span>(<span class="string">timeUpdate:</span>) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure>
<p>那么当你滑动或者保持你的手指在scrollView上的时候，timer是不会被响应的，这不是因为刷新视图的操作被占用，而是因为当你没有显式声明的时候，你所定义的timer默认都是加在主线程上，并且，当你在对scrollView进行操作的时候，你的timer的事件根本不会被响应到，这就得说到runloop了。而runloop也是底层原理中相当重要的一部分。我们先从它说起。</p>
<h2 id="u4EC0_u4E48_u662Frunloop"><a href="#u4EC0_u4E48_u662Frunloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h2><p>Runloop，顾名思义就是运行的循环。简单理解就是多线程机制中的基础，它能够接收外部事件的输入，并且在有事件的时候保持运行，在没有事件的时候进入休眠。并且它对于线程的消息处理机制进行了很好的封装。</p>
<p>对于线程来说，每一个线程都有一个runloop对象，是否能向某个线程的runloop发送事件取决于你是否启动了这个runloop，系统会默认在你的程序启动的时候运行主线程上的runloop，但是你自定义创建出来的线程可以不需要运行runloop，一些第三方框架，例如AFNetworking，就有在自己的线程上维护一个runloop对象。</p>
<p>在 Core Foundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef </li>
<li>CFRunLoopTimerRef </li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>他们的关系可以从NSRunloop对象的结构定义中得出。首先，runloop对象在Cocoa和Core Foundation中都有实现，但是他们做了很好的桥接，你可以直接调用</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><span class="line">CFRunLoopRef runLoopRef = currentThreadRunLoop.getCFRunLoop<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>来获取一个CoreFoundation中的runloop对象。然后，当你在查看NSRunloop的结构的时候，你应该能看到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">&lt;CFRunLoop <span class="number">0x7fd360f5af30</span> [<span class="number">0x1090a1180</span>]&gt;&#123;wakeup port = <span class="number">0x4507</span>, stopped = <span class="literal">false</span>, ignoreWakeUps = <span class="literal">true</span>, </span><br><span class="line">current mode = (none),</span><br><span class="line">common modes = &lt;CFBasicHash <span class="number">0x7fd360f5a470</span> [<span class="number">0x1090a1180</span>]&gt;&#123;type = <span class="keyword">mutable</span> <span class="built_in">set</span>, count = <span class="number">1</span>,</span><br><span class="line">entries =&gt;</span><br><span class="line">	<span class="number">2</span> : &lt;CFString <span class="number">0x10907d080</span> [<span class="number">0x1090a1180</span>]&gt;&#123;contents = <span class="string">"kCFRunLoopDefaultMode"</span>&#125;&#125;,</span><br><span class="line">common mode items = (null),</span><br><span class="line">modes = &lt;CFBasicHash <span class="number">0x7fd360f5b2b0</span> [<span class="number">0x1090a1180</span>]&gt;&#123;type = <span class="keyword">mutable</span> <span class="built_in">set</span>, count = <span class="number">1</span>,</span><br><span class="line">entries =&gt;</span><br><span class="line">	<span class="number">2</span> : &lt;CFRunLoopMode <span class="number">0x7fd360f5aff0</span> [<span class="number">0x1090a1180</span>]&gt;&#123;name = kCFRunLoopDefaultMode, port <span class="built_in">set</span> = <span class="number">0x4703</span>, timer port = <span class="number">0x4803</span>, </span><br><span class="line">	sources0 = (null),</span><br><span class="line">	sources1 = (null),</span><br><span class="line">	observers = &lt;CFArray <span class="number">0x7fd360f5b1a0</span> [<span class="number">0x1090a1180</span>]&gt;&#123;type = <span class="keyword">mutable</span>-small, count = <span class="number">1</span>, values = (</span><br><span class="line">	<span class="number">0</span> : &lt;CFRunLoopObserver <span class="number">0x7fd360f5c7f0</span> [<span class="number">0x1090a1180</span>]&gt;&#123;valid = Yes, activities = <span class="number">0xfffffff</span>, repeats = Yes, order = <span class="number">0</span>, callout = currentRunLoopObserver (<span class="number">0x10855b340</span>), context = &lt;CFRunLoopObserver context <span class="number">0x7fd361213d70</span>&gt;&#125;</span><br><span class="line">)&#125;,</span><br><span class="line">	timers = &lt;CFArray <span class="number">0x7fd360e020d0</span> [<span class="number">0x1090a1180</span>]&gt;&#123;type = <span class="keyword">mutable</span>-small, count = <span class="number">1</span>, values = (</span><br><span class="line">	<span class="number">0</span> : &lt;CFRunLoopTimer <span class="number">0x7fd360e01f90</span> [<span class="number">0x1090a1180</span>]&gt;&#123;valid = Yes, firing = No, interval = <span class="number">1</span>, tolerance = <span class="number">0</span>, next fire date = <span class="number">463742311</span> (-<span class="number">2.53606331</span> @ <span class="number">23607719248079</span>), callout = (NSTimer) [SCCustomThread handleTimerTask] (<span class="number">0x1086416f1</span> / <span class="number">0x10855b560</span>) (/Users/useruser/Library/Developer/CoreSimulator/Devices/<span class="number">424</span>D3C6E-<span class="number">8</span>DC0-<span class="number">418</span>B-A2EC-<span class="number">8</span>EDF89507348/data/Containers/Bundle/Application/<span class="number">4</span>D07AF38-<span class="number">9</span>BFC-<span class="number">4617</span>-BAE0-<span class="number">4</span>CB0D7966CC8/runloopTest.app/runloopTest), context = &lt;CFRunLoopTimer context <span class="number">0x7fd360e01f70</span>&gt;&#125;</span><br><span class="line">)&#125;,</span><br><span class="line">	currently <span class="number">463742313</span> (<span class="number">23610255156065</span>) / soft deadline in: <span class="number">1.84467441e+10</span> sec (@ <span class="number">23607719248079</span>) / hard deadline in: <span class="number">1.84467441e+10</span> sec (@ <span class="number">23607719248079</span>)</span><br><span class="line">&#125;,&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个runloop对象包含各种Mode——currentMode，common mode，modes等等，这里的示例我只指定了一个defaultMode。每个mode对应了source，observers和timers。</p>
<blockquote>
<p>也许你会注意到 source 包括了source0和source1两个版本。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</li>
</ul>
</blockquote>
<p>CFRunLoopObserver类型的对象也可以称之为观察者。每个观察者都包含了一个回调，当runloop的状态发生变化时，你可以通过回调来知道当前的状态。</p>
<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="image"></p>
<p>在你的程序中，runloop的过程实际上是一个无限循环的循环体，这个循环体是由你的程序来运行的。主线程的runloop由于系统已经实现并且没有它程序就不能运行，因此不需要我们手动去运行这个runloop。然而如果我们需要在自定义的线程中使用到runloop，我们则需要用一个do…while循环来驱动它。而runloop对象负责不断地在循环体中运行传进来的事件，然后将事件发给相应的响应。</p>
<blockquote>
<p>如果你打开你的程序的main.m，你就会发现其实主线程的runloop就是在main函数中进行的，并且系统已经为你生成好了autoreleasepool，因此你也无需操心主线程上的内存释放到底是在什么时候执行了：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate class]));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据响应源的不同，runloop也被分成了许多种不同的模式，这就是被Cocoa和Core Foundation都封装了的runloopMode。主要是这么几种：</p>
<ul>
<li>NSDefaultRunLoopMode: 大多数工作中默认的运行方式。</li>
<li>NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态。</li>
<li>NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。</li>
<li>NSEventTrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。</li>
<li>NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、NSEventTrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。</li>
</ul>
<p>在文首的情况中，我们可以根据苹果官方文档的定义知道，当你在滑动页面的时候，主线程的runloop自动进入了NSEventTrackingRunLoopMode，而你的timer只是运行在DefaultMode下，所以不能响应。那么最简单的办法就是将你的timer添加在其他的mode下，像这样即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attr_selector">[[NSRunLoop currentRunLoop]</span> <span class="tag">addTimer</span><span class="pseudo">:self</span><span class="class">.timer</span> <span class="tag">forMode</span><span class="pseudo">:NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
<p>需要注意的是CommonModes其实并不是一种Mode，而是一个集合。因此runloop并不能在CommonModes下运行，相反，你可以将需要输入的事件源添加为这个mode，这样无论runloop运行在哪个mode下都可以响应这个输入事件，否则这个事件将不会得到响应。</p>
<h2 id="Input_Source"><a href="#Input_Source" class="headerlink" title="Input Source"></a>Input Source</h2><p>输入源包括三种，端口，自定义输入源和performSelector的消息。根据上面的图我们可以看出，在runloop接收到消息并执行了指定方法的时候，它会执行runUntilDate:这个方法来退出当前循环。</p>
<p>端口源是基于Mach port的，其他进程或线程可以通过端口来发送消息。这里的知识点需要深入到Mach，就已经比较晦涩难懂了……这里你只需要知道你可以用Cocoa封装的NSPort对象来进行线程之间的通信，而这种通信方式所产生的事件就是通过端口源来传入runloop的。关于Mach port的更深层介绍可以看<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="external">这篇</a>。</p>
<p>自定义输入源。Core Foundation提供了CFRunLoopSourceRef类型的相关函数，可以用来创建自定义输入源。</p>
<p>performSelector输入源:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在主线程的Run Loop下执行指定的 @selector 方法</span></span><br><span class="line"><span class="string">performSelectorOnMainThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span></span><br><span class="line"><span class="string">performSelectorOnMainThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span><span class="string">modes:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前线程的Run Loop下执行指定的 @selector 方法</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">onThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">onThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span><span class="string">modes:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前线程的Run Loop下延迟加载指定的 @selector 方法</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">withObject:</span><span class="string">afterDelay:</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">withObject:</span><span class="string">afterDelay:</span><span class="string">inModes:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消当前线程的调用</span></span><br><span class="line"><span class="string">cancelPreviousPerformRequestsWithTarget:</span></span><br><span class="line"><span class="string">cancelPreviousPerformRequestsWithTarget:</span><span class="string">selector:</span><span class="string">object:</span></span><br></pre></td></tr></table></figure>
<h2 id="runloop_u751F_u547D_u5468_u671F"><a href="#runloop_u751F_u547D_u5468_u671F" class="headerlink" title="runloop生命周期"></a>runloop生命周期</h2><p>每一次runloop其实都是一次循环，runloop会在循环中执行runUntilDate: 或者runMode: beforeDate: 来开始每一个循环。而每一个循环又分为下面几个阶段，也就是runloop的生命周期：</p>
<ul>
<li>kCFRunLoopEntry 进入循环</li>
<li>kCFRunLoopBeforeTimers 先接收timer的事件</li>
<li>kCFRunLoopBeforeSources 接收来自input source的事件</li>
<li>kCFRunLoopBeforeWaiting 如果没有事件，则准备进入休眠模式，在这里，如果没有事件传入，runloop会运行直到循环中给定的日期，如果你给的是distantFuture，那么这个runloop会无限等待下去</li>
<li>kCFRunLoopAfterWaiting 从休眠中醒来，直接回到kCFRunLoopBeforeTimers状态</li>
<li>kCFRunLoopExit 退出循环</li>
</ul>
<p>这些状态也是一个枚举类型，系统是这么定义的，你可以使用observer来观测到这些状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">CF_OPTIONS</span><span class="params">(CFOptionFlags, CFRunLoopActivity)</span> </span>&#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1U</span>L &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1U</span>L &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1U</span>L &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1U</span>L &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1U</span>L &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们下面做一个测试，在demo中我们定义了一个新的线程类，这样我们可以自己启动和维护它的runloop对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Thread Enter"</span>);</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"This is a test thread"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *currentThreadRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="comment">// CFRunLoopRef currentThreadRunLoop = CFRunLoopGetCurrent();</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(k<span class="built_in">CFAllocatorDefault</span>, k<span class="built_in">CFRunLoopAllActivities</span>, <span class="literal">YES</span>, <span class="number">0</span>, &amp;currentRunLoopObserver, &amp;context);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRef</span> runLoopRef = currentThreadRunLoop<span class="variable">.getCFRunLoop</span>;</span><br><span class="line">            <span class="built_in">CFRunLoopAddObserver</span>(runLoopRef, observer, k<span class="built_in">CFRunLoopDefaultMode</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个Timer，重复调用来驱动Run Loop</span></span><br><span class="line">        <span class="comment">//[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handleTimerTask) userInfo:nil repeats:YES];</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            [currentThreadRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">3</span>]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入源或者timer对于runloop来说是必要条件，如果没有添加任何输入源，则runloop根本不会启动，所以上面的代码中添加timer的操作，实际上是添加了一个默认的事件输入源，能让runloop保持运行。但是实际上，当你创建好一个runloop对象后，任何输入的事件都可以触发runloop的启动。</p>
<p>例如下面的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self <span class="string">performSelector:</span><span class="annotation">@selector</span>(selectorTest) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure>
<p>记住，如果你需要自己来启动和维护runloop的话，核心就在于一个do…while循环，你可以为runloop的跳出设置一个条件，也可以让runloop无限进行下去。在runloop没有接收到事件进入休眠状态之后，如果调用performSelector，runloop的状态变化如下：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopAfterWaiting</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">fuck</span><br><span class="line">fuck_1</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopExit</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopExit</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeWaiting</span><br></pre></td></tr></table></figure>
<p>在这里我连续调用了两次performSelector，可以看到runloop也经历了两个循环，而如果只调用一次的话，不会有多出来的那次runloop（你可以自己尝试一下），这是否说明每一次performSelector执行完毕之后都会立即结束当前runloop开始新的，苹果的官方文档里有一句话：</p>
<blockquote>
<p>The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration</p>
</blockquote>
<p>应该意思是并不是像上面看到的结果那样每一次循环执行一次，而是有一个待执行的操作队列。如果我同时执行四次performSelector，像这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self <span class="string">performSelector:</span><span class="annotation">@selector</span>(selectorTest) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="annotation">@selector</span>(selectorTest_1) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="annotation">@selector</span>(selectorTest_2) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="annotation">@selector</span>(selectorTest_2) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure>
<p>实际上得到的结果和上面是一样的，然而当我将他们的waitUntilDone参数都设置为YES之后，我们可以看到不一样的地方：</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Thread</span> Enter</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">fuck</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopExit</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">fuck_1</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopExit</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">fuck_2</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopExit</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">fuck_2</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopExit</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopEntry</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeTimers</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeSources</span><br><span class="line">Current <span class="keyword">thread</span> Run <span class="keyword">Loop</span> activity: kCFRunLoopBeforeWaiting</span><br></pre></td></tr></table></figure>
<p>你可以看到每一个performSelector操作都单独执行了一个runloop，从苹果的文档中我们可以找到这个方法的定义：</p>
<blockquote>
<ul>
<li>performSelector:onThread:withObject:waitUntilDone:</li>
<li>performSelector:onThread:withObject:waitUntilDone:modes:</li>
</ul>
<p>Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.</p>
</blockquote>
<p>也就是说，waitUntilDone意味着这个操作是否会在当前线程阻塞其他的输入源，如果等于True，则每一次runloop循环只会处理这一个selector的调用，如果为False，则队列中后面等待着的selector调用都会在同一次runloop循环中执行。至于上文的执行了两个runloop循环的现象，我猜测应该是当runloop从休眠模式被唤醒的时候，当前循环执行完唤醒的操作后就会立即结束，释放掉之前可能累积下来的内存，然后开始新的循环，将队列中的其他输入逐个放进runloop循环中执行。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5148_u6765_u8BF4_u4E00_u4E2A_u5F88_u7B80_u5355_u7684_u5B9E_u4F8B"><a href="#u5148_u6765_u8BF4_u4E00_u4E2A_u5F88_u7B80_u5355_u7684_u]]>
    </summary>
    
      <category term="NSThread" scheme="http://sergiochan.github.io/tags/NSThread/"/>
    
      <category term="iOS" scheme="http://sergiochan.github.io/tags/iOS/"/>
    
      <category term="runloop" scheme="http://sergiochan.github.io/tags/runloop/"/>
    
      <category term="iOS菜鸟心得" scheme="http://sergiochan.github.io/categories/iOS%E8%8F%9C%E9%B8%9F%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[objective-c_runtime是什么]]></title>
    <link href="http://sergiochan.github.io/2015/10/22/objective-c-runtime%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://sergiochan.github.io/2015/10/22/objective-c-runtime是什么/</id>
    <published>2015-10-22T11:03:54.000Z</published>
    <updated>2015-12-18T13:13:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="u5F53_u4F60_u8C03_u7528_u4E00_u4E2A_u65B9_u6CD5_u7684_u65F6_u5019_uFF0C_u53D1_u751F_u4E86_u4EC0_u4E48"><a href="#u5F53_u4F60_u8C03_u7528_u4E00_u4E2A_u65B9_u6CD5_u7684_u65F6_u5019_uFF0C_u53D1_u751F_u4E86_u4EC0_u4E48" class="headerlink" title="当你调用一个方法的时候，发生了什么"></a>当你调用一个方法的时候，发生了什么</h2><p>在Objective-C里，当你调用一个方法的时候，例如</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">[foo <span class="function"><span class="keyword">method</span>];</span></span><br></pre></td></tr></table></figure>
<p>的时候，实际上编译器会将它转化为这样</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">objc_msgSend</span><span class="params">(foo,selector)</span></span></span><br></pre></td></tr></table></figure>
<p><code>selector</code>就是你能够经常用到的那个addTarget中使用到的，它在runtime机制中相当于一个函数的名牌，而IMP则是函数的实现。<br>消息机制的关键是编译器是如何处理每一个类和对象的。一般来说，一个类会被编译成这样的结构，一个指向父类的指针，一个类的分派表。这个列表里存的是所有的<code>selector</code>和他们对应的方法的地址。没错，每个方法都有一个地址，通过地址来调用方法。而这个地址，就是由函数指针IMP来得到的。</p>
<blockquote>
<p>如果你学过编译原理，并且用其他语言自己写过一个编译器的话，你应该了解写一个基础语言调用方法的时候都会有一个全局的方法表，然后调用的过程实际上是去这个方法表中查找对应方法地址的过程。而Objective-C也是类似的，但是由于它是面向对象的，而且又有着这个runtime的特性，也就意味着在Objective-C中的函数调用实际上是在运行时动态的查询当前类和其父类的分派表。<br>在分派表中，每一个selector都是由SEL对应IMP的形式存储着。我们可以找到SEL的定义</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector   *SEL;</span><br></pre></td></tr></table></figure>
<p>所以SEL实际上表示的是方法的签名。在不同的类中如果有相同名称相同参数的方法，则他们的SEL是一样的。但是对应的IMP，也就是函数指针，是在runtime的时候才会动态的去查询然后调用的。<br>IMP的定义则是：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">typedef id <span class="list">(<span class="keyword">*IMP</span>)</span><span class="list">(<span class="keyword">id</span>, SEL, ...)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看出，这个被指向的函数包含一个接收消息的对象id, 调用方法的签名 SEL，以及不定个数的方法参数，并返回一个id。也就是说 IMP 是消息最终调用的执行代码，是方法真正的实现代码。对于对象来说，当一个对象被分配空间并初始化之后，对象有一个指向它的类结构，也就是上面提到的这些东西的指针。这就是你所熟悉的<code>isa</code>，这样可以通过自身访问到自身的类以及无穷的父类里的方法列表。<br>比方说，有一个继承于<code>NSObject</code>的foo类，然后又有一个foo1类继承于foo，这时候我们初始化一个foo1的实例对象A，然后调用A的某个方法B，这时候其实也就是向A发了一个消息，要调用B的<code>selector</code>。首先会做的是判断接收对象是不是nil，要记住空对象可以接收消息，因为当你向一个空对象发消息的时候，实际上处理的是一个<code>nil-handler</code>，而这个handler是啥也不会做的，因此什么也不会发生。<br>接下来系统在运行时会先从foo1的分派表中寻找B的<code>selector</code>，如果没有，则向foo类找，如果有，则直接调用了，然后直到找到<code>NSObject</code>，如果这时候还找不到，那么就会报经典的<strong>‘UnRecognized selector sent to instance’</strong>，如果找到了，那就按照对应的地址找到函数，然后把需要的参数一起传过去。</p>
<p>这里有个黑科技，其实也很简单，这个报错和崩溃来源于动态查询函数实现最终失败的调用<code>doesNotRecognizeSelector</code>，如果你重写了这个方法，那么对于这个类的对象的错误函数调用就可以避免crash了。但是实际上并没有什么卵用，这反而还掩盖了在消息发送和转发的过程中出现的一些异常。<br>当然，系统为了加快这个速度，在上面这一步之前加上了分派表的缓存，秉承着你调用过的函数就有可能再次被调用的原则，你所调用过的函数会被加入到这个缓存表里来。因此，你可以认为当你的应用运行了一会儿之后，这个缓存会变大，然后这时候消息机制也会越变越快。<br>最关键的点是在当这个查询最后在分派表中没有找到相应实现的时候，会进行一系列调用。而在这个过程中，我们可以做到动态绑定函数地址，动态重定向实现对象和动态重定向实现的函数地址。函数的地址也就是你常见的<code>IMP</code>。<br>如果找到函数实现，则不会进入下面的流程。如果没有找到函数的实现，则会先调用<code>resolveInstanceMethod</code>这个函数。这个函数是在没有找到函数实现的情况下的第一道补救，这时候你可以通过<code>class_addMethod</code>动态添加函数。<br>一个Objective-C的函数实际上就是一个简单地带有至少两个参数self和_cmd的C方法体。如官方文档给出的这样结构：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">    <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>resolveInstanceMethod</code>的时候，你可以这样动态添加一个函数，并且如果当你添加了函数的时候，你需要return YES。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="keyword">if</span> (aSEL == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">          class_addMethod([<span class="keyword">self</span> class], aSEL, (IMP) dynamicMethodIMP, <span class="string">"v@:"</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:aSEL];&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这是第一个解决办法，当然，如果你返回了YES，则消息就将被发送到你刚添加的这个IMP去了，也就不会继续下面的消息转发机制了。因此苹果的官方文档就说，动态添加函数是在消息转发机制之前进行的。如果你动态添加了某些函数的实现，但还是希望他们能进入下面的消息转发机制里，你也可以让指定的<code>selector</code>返回NO就好了。<br>接下去就是消息转发的流程了。<br>一进入消息转发机制之后，runtime首先会调用<code>forwardingTargetForSelector</code>。这是让你能够指定对象来响应这个方法的地方，返回值是一个id对象，如果返回的是非空且不是自身的时候，runtime会将消息发送给这个对象，试图获得返回。当这一步仍然为空，则会进入下一步的流程。<br>在下一步调用<code>forwardInvocation</code>之前，会走一个函数调用叫做<code>- (NSMethodSignature *)methodSignatureForSelector:(SEL)selector</code>，在这里你可以为没有找到对应IMP的selector添加修改他们的方法签名，这里如果你抛出了一个函数的签名，则会继续传递到下一步中，如果抛出了nil，则你再也不会进到下一步了，在这里就直接报错了。你可以在这里做一些有趣的事情，例如修改一些没有实现的selector签名为一些已知的或者固定格式的，然后再由下面的<code>forwardInvocation</code>来提供分发之类的实现。<br>当通过了上一步仍然没有函数实现能够响应这条消息的时候，runtime会向对象发送一个 <code>forwardInvocation：</code>的消息，并且会把<strong>对函数的调用和附带的参数</strong>封装成一个<code>NSInvocation</code>对象传过来。下面设想的是这么一个场景，你希望对A类对象的B方法调用由C类对象的B方法来响应。是的，你可以让A类来继承B类，但是很多情况下这会让情况变得更糟糕，特别是OC并不支持多继承的情况下。这时候就可以用消息转发机制来实现动态绑定啦！当消息不能被正确响应的时候，你需要确定消息将要发送的对象，然后将最开始的调用和参数列表一起发送过去。消息可以用<code>invokeWithTarget</code>来发送：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">forwardInvocation:</span>(NSInvocation *)anInvocation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([someOtherObject <span class="string">respondsToSelector:</span></span><br><span class="line">            [anInvocation selector]])</span><br><span class="line">        [anInvocation <span class="string">invokeWithTarget:</span>someOtherObject];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        [<span class="keyword">super</span> <span class="string">forwardInvocation:</span>anInvocation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有，记住每个<code>NSObject</code>的子类都继承了这个方法，但是如果你没有手动去重写的话，NSObject里的实现只会马上调用<code>doesNotRecognizeSelector</code>，也就是前面经典的报错。因此你需要手动重写它。<br>这个方法所获得的返回都会返回给最初调用的发送者，不管他是谁。<br><code>forwardInvocation</code>可以作为未知消息的分发器，让他们各自发送到合理的对象那里去，也可以在这里就过滤掉一些可能会出错的返回和错误信息。<br>利用消息转发机制我们也可以实现类似多继承的功能。如果A类中不存在B方法，而C类中有B方法，通过消息转发，我们就可以从A类调用B方法，并且通过<code>forwardInvocation</code>来分发，我们可以实现类似多继承的功能。但是这两者毕竟还是有区别的，因为多继承是一个可以在一个类中拥有许多父类的方法和属性。但是通过消息转发，我们也只是在消息层面上实现了拥有许多父类方法的能力。<br>另外要提的就是，即使你做了消息转发来实现类似多继承的能力，当你调用<code>respondToSelector</code>或<code>isKindOfClass</code>的时候，他们只会去你自身的继承树里面去寻找<code>selector</code>，而并不会去识别你的消息转发机制。<br>因此，当你需要为你的超级对象生成一个小的代理对象（surrodate object）的时候，或者你确实需要动态扩展你的类的时候，你需要重写很多方法。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ( [super respondsToSelector:aSelector] )</span><br><span class="line"><span class="command">        return</span> YES;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        /* Here, test whether <span class="keyword">the</span> aSelector message can     *</span><br><span class="line">         * be forwarded <span class="keyword">to</span> another object <span class="keyword">and</span> whether <span class="keyword">that</span>  *</span><br><span class="line">         * object can respond <span class="keyword">to</span> <span class="keyword">it</span>. Return YES <span class="keyword">if</span> <span class="keyword">it</span> can.  */</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command">    return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照官方文档，你总共需要重写下面几个方法，并且都加上你的消息转发机制。</p>
<ul>
<li><code>respondsToSelector</code></li>
<li><code>isKindOfClass</code></li>
<li><code>instancesRespondToSelector</code></li>
<li><code>conformsToProtocol</code>（如果有用到协议）</li>
<li><code>methodSignatureForSelector</code></li>
</ul>
<p>哎，可是谁又会用得到呢。官方文档最后的小贴士说，这项技术不在走投无路的时候不要用，它不是用来替代继承的。对于我们最多只能是了解并且用到最表层的例如消息转发还有错误的拦截之类，在实际运用中也只对程序运行时的机制有了更好的了解，但是仍然并没有什么卵用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="u5F53_u4F60_u8C03_u7528_u4E00_u4E2A_u65B9_u6CD5_u7684_u65F6_u5019_uFF0C_u53D1_u751F_u4E86_u4EC0_u4E48"><a href="#u5F53_u4F60_u8C03_u]]>
    </summary>
    
      <category term="Objective-C" scheme="http://sergiochan.github.io/tags/Objective-C/"/>
    
      <category term="objc_msgSend" scheme="http://sergiochan.github.io/tags/objc-msgSend/"/>
    
      <category term="runtime" scheme="http://sergiochan.github.io/tags/runtime/"/>
    
      <category term="iOS菜鸟心得" scheme="http://sergiochan.github.io/categories/iOS%E8%8F%9C%E9%B8%9F%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[tornado-TCP服务器间内部通讯TCP服务器性能验证]]></title>
    <link href="http://sergiochan.github.io/2015/07/19/tornado-TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%97%B4%E5%86%85%E9%83%A8%E9%80%9A%E8%AE%AFTCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD%E9%AA%8C%E8%AF%81/"/>
    <id>http://sergiochan.github.io/2015/07/19/tornado-TCP服务器间内部通讯TCP服务器性能验证/</id>
    <published>2015-07-19T01:08:40.000Z</published>
    <updated>2015-12-19T01:19:46.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文附带项目Github仓库地址，随手star是个好习惯：<br><a href="https://github.com/SergioChan/tornado-TCP" target="_blank" rel="external">https://github.com/SergioChan/tornado-TCP</a></p>
</blockquote>
<h1 id="u4E3A_u4EC0_u4E48_u8981_u6709tornado-TCP"><a href="#u4E3A_u4EC0_u4E48_u8981_u6709tornado-TCP" class="headerlink" title="为什么要有tornado-TCP"></a>为什么要有tornado-TCP</h1><p>在实际的业务场景中，当一个系统复杂到一定程度后，很多服务都需要被独立地分割出来，部署到独立的服务器上。例如日志服务，图像服务，短信服务和一些数据分析服务这些可能会被许多功能模块共用的且对服务器性能有一定消耗的服务。当功能划分后，各服务器之间就需要通过内部调用连接在一起，通常来说简便的做法就是通过HTTP请求，这样外部和内部访问的服务器都是通用的，对于开发，维护和部署来说是省去了不少功夫。但是，一方面，有一些HTTP Server可能会同时处理内部和外部请求，如果从其他模块发来的内部请求过多，占用了HTTP Server的处理资源，外部客户端的请求可能会因此变慢，因此对于一个想要拥有更高可靠性和稳定性的大型系统来说，将内部调用和外部调用从逻辑上分离开是一个比较好的优化手段。另一方面，虽然在这种场景下HTTP请求的性能不会差到哪里去，在拥有局域网的情况下，这种内部调用的处理速度会相当快，它的连接也会很快的被释放和刷新，但是由于HTTP毕竟是TCP上的应用层，TCP省去了一些HTTP Header的传输和消耗，因此一定意义上采用更低级的TCP来作为内部调用的传输手段，既是一种较为标准和专业化的方法，也是一种更加优化的方法。<br>我们先要理解HTTP连接和TCP连接的区别。首先，HTTP连接是基于TCP连接的。HTTP（HyperText Transport Protocol）是超文本传输协议的缩写。 HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，其中，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。它的最显著的特点是客户端发送的每次请求都需要服务器回送响应，在请求结束后，客户端会主动释放连接。从建立连接到关闭连接的过程称为“一次连接”。这个特点也使得HTTP协议成为了包括移动和web浏览器在内的客户端和服务器端通信的标准途径，因为大部分客户端和服务器的交互都是一次性的，例如一次读和一次写。当每次交互都是原子的时候，在没有特别需求的场景维持长连接对于资源是一种浪费，因此大部分客户端和服务器通信都采用了HTTP协议。虽然现在已经有一些HTTP长连接的实现，但它的机制其实也是基于HTTP协议的，通过类似心跳的模式保持HTTP连接不会被释放。<br>TCP提供一种面向连接的、可靠的字节流服务。面向连接意味着两个使用TCP的应用，通常是一个客户和一个服务器。在彼此交换数据包之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信。在普遍的场景中，TCP长连接常用于客户端推送、即时通信的实现。当然，在很多情况下，TCP也被用来作为服务器内部服务调用的实现。像日志服务这种公用的服务模块，整个系统对它的调用是十分频繁的，因此采用“一次连接”模式的HTTP请求和采用保持连接的TCP请求的区别十分明显，采用TCP会使系统省下大量的资源去重新建立和释放连接。</p>
<h1 id="u5B9E_u9645_u7ED3_u679C"><a href="#u5B9E_u9645_u7ED3_u679C" class="headerlink" title="实际结果"></a>实际结果</h1><p>对于服务器内部通信采用HTTP协议和TCP协议的性能表现差异，我用对比实验的方式来验证结果。首先，我模拟了传统的HTTP Server的环境，采用了Django作为服务器，并实现了一个基于HTTP协议的内部调用的协议。同时，我将tornado-TCP也部署在相同机器上，在Django上同样实现了一个基于TCP协议的内部调用的协议。然后通过压力测试，得出了以下结果：</p>
<h2 id="u6BCF_u79D2_u5E76_u53D1_u7684_u6D41_u91CF_u6D4B_u8BD5_uFF1A"><a href="#u6BCF_u79D2_u5E76_u53D1_u7684_u6D41_u91CF_u6D4B_u8BD5_uFF1A" class="headerlink" title="每秒并发的流量测试："></a>每秒并发的流量测试：</h2><p>基于HTTP的内部调用的协议请求：<br>Used 1.00223088264 s for requests, success count is: 289<br>基于TCP的内部调用的协议请求：<br>Used 1.00016713142 s for requests, success count is: 633  </p>
<h2 id="u4E00_u5B9A_u6570_u91CF_u5E76_u53D1_u8BF7_u6C42_u7684_u5904_u7406_u901F_u5EA6_uFF1A"><a href="#u4E00_u5B9A_u6570_u91CF_u5E76_u53D1_u8BF7_u6C42_u7684_u5904_u7406_u901F_u5EA6_uFF1A" class="headerlink" title="一定数量并发请求的处理速度："></a>一定数量并发请求的处理速度：</h2><p>基于HTTP的内部调用的协议请求：<br>Used 47.3748078346 s for 10,000 requests, success count is: 9998<br>Used 281.623967171 s for 50,000 requests, success count is: 49999<br>基于TCP的内部调用的协议请求：<br>Used 14.8007540703 s for 10,000 requests, success count is: 9999<br>Used 123.114969015 s for 50,000 requests, success count is: 49999<br>以上的测试结果均基于相同的Django环境，由于测试的时候使用的是单进程的Django自带的HTTP Server，因此TCP Server也采用了单进程模式。如果切换成多进程模式，采用的原理和tornado相同。也就是说，当基于Django的HTTP Server以单进程模式运行的时候，其处理速度大概是相同条件的tornado-TCP服务器的一半以上。<br>这是这三个服务器的进程情况：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">501</span> <span class="number">68455</span>  <span class="number">1492</span>   <span class="number">0</span> <span class="number">10</span>:<span class="number">11</span>上午 ??         <span class="number">0</span>:<span class="number">08.05</span> /usr/bin/python /Users/useruser/tornado-TCP/Server/Manage.py</span><br><span class="line"><span class="number">501</span> <span class="number">68465</span> <span class="number">68433</span>   <span class="number">0</span> <span class="number">10</span>:<span class="number">12</span>上午 ttys001    <span class="number">0</span>:<span class="number">00.63</span> /usr/bin/python manage.py runserver <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9555</span></span><br><span class="line"><span class="number">501</span> <span class="number">68468</span> <span class="number">68465</span>   <span class="number">0</span> <span class="number">10</span>:<span class="number">12</span>上午 ttys001    <span class="number">0</span>:<span class="number">08.13</span> /usr/bin/python manage.py runserver <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9555</span></span><br><span class="line"><span class="number">501</span> <span class="number">68475</span> <span class="number">68472</span>   <span class="number">0</span> <span class="number">10</span>:<span class="number">12</span>上午 ttys002    <span class="number">0</span>:<span class="number">00.43</span> /usr/bin/python manage.py runserver <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9556</span></span><br><span class="line"><span class="number">501</span> <span class="number">68478</span> <span class="number">68475</span>   <span class="number">0</span> <span class="number">10</span>:<span class="number">12</span>上午 ttys002    <span class="number">0</span>:<span class="number">43.47</span> /usr/bin/python manage.py runserver <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9556</span></span><br></pre></td></tr></table></figure>
<p>其中9555端口运行的是内部调用的HTTP Server，9556端口运行的是主测试服务器，TCP服务器运行在8889端口上。</p>
<h1 id="u6846_u67B6_u4ECB_u7ECD"><a href="#u6846_u67B6_u4ECB_u7ECD" class="headerlink" title="框架介绍"></a>框架介绍</h1><h2 id="tornado-TCP_framework"><a href="#tornado-TCP_framework" class="headerlink" title="tornado-TCP framework"></a>tornado-TCP framework</h2><p>tornado-TCP的框架可以由以上的架构图来表示。和传统的HTTP Server相比，它相当于是在不同的Server之间建立了一个长连接，而这个连接的主体是一个IOStream，由Connection类来保持监听和字节流的读取。其余模块都是参考传统HTTP Server的架构来添加的。<br>任意其他连接到tornado-TCP的服务器实际上都是一个客户端。每个客户端都需要自己维护一个和tornado-TCP服务器的TCP Socket连接。如果这种内部调用在可预见的范围内十分的频繁，这个连接最好在全局建立和维护，随着服务器的启动初始化。保持IOStream的连接可以使得服务器之间的局域网通信比传统的HTTP请求更快。</p>
<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>Any other server that was connected to this tornado-TCP server will be represented as a client-server. Each client-server will maintain a TCP connection with tornado-TCP server. If the connection will be used very frequently, it’s better not to close it. Keeping an IOStream for the connection will make the communication in the server-side Local Area Network faster than typical HTTP request.<br>Connection will read the request from IOStream and handle the requests. When a request handling is over, the Connection will automatically read the stream to get the next request. As the source code shown below:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_request</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    tmp_body = data[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    request = Request(address=self._address, Body=tmp_body)</span><br><span class="line">    handler = urls.Handler_mapping.get(request.cmdid)</span><br><span class="line"></span><br><span class="line">    handler_instance = handler()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(handler_instance,BaseHandler):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            handler_instance.process(request=request)</span><br><span class="line">            self._stream.write(handler_instance.res)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            baseLogger.error(e.message)</span><br><span class="line"></span><br><span class="line">self.read_request()</span><br></pre></td></tr></table></figure>
<h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p>Handler is the class type for processing the request object. You can sub-class your own Handler from BaseHandler to implement custom processing method. This is the sample of TestHandler:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="decorator">@urls.handler(constant.TEST_CMDID)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHandler</span><span class="params">(BaseHandler)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self,request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(request, Request):</span><br><span class="line">            <span class="keyword">print</span> request.params</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError</span><br></pre></td></tr></table></figure>
<p>Notice the decorator @urls.handler which is used to add mapping between cmdId and Handler. The definition of this decorator is in the urls.py. Each custom Handler should decorated by this decorator.</p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>Request is the basic object type in the IOStream. Each Request is delimited by a delimiter ‘\n’.Request is transported in a serialization mode, using normal json type.<br>To extend Request, define a subclass and there is no need to override anything.<br>Request has following parameters:  </p>
<ul>
<li>1.address: simple ip address combined with port number representing the request origin server.</li>
<li>2.rawBody: raw content of the request body</li>
<li>3.cmdid: command id defines in Command</li>
<li>4.timestamp: the date when request was sent</li>
<li>5.params: a dict that storage all the data it takes</li>
</ul>
<p>详细介绍和代码请前往<a href="https://github.com/SergioChan/tornado-TCP" target="_blank" rel="external">https://github.com/SergioChan/tornado-TCP</a><br>欢迎关注和批评指导！</p>
]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文附带项目Github仓库地址，随手star是个好习惯：<br><a href="https://github.com/SergioChan/tornado-TCP" target="_blank" rel="external">https://]]>
    </summary>
    
      <category term="TCP" scheme="http://sergiochan.github.io/tags/TCP/"/>
    
      <category term="tornado" scheme="http://sergiochan.github.io/tags/tornado/"/>
    
      <category term="Python学习笔记" scheme="http://sergiochan.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Python利用深度优先搜索解数独程序的实现]]></title>
    <link href="http://sergiochan.github.io/2015/05/19/Python%E5%88%A9%E7%94%A8%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E8%A7%A3%E6%95%B0%E7%8B%AC%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://sergiochan.github.io/2015/05/19/Python利用深度优先搜索解数独程序的实现/</id>
    <published>2015-05-19T13:30:29.000Z</published>
    <updated>2016-02-09T02:26:30.000Z</updated>
    <content type="html"><![CDATA[<blockquote>
<p>本文附带项目Github仓库地址，随手star是个好习惯：<br><a href="https://github.com/SergioChan/Python-Sudoku" target="_blank" rel="external">https://github.com/SergioChan/Python-Sudoku</a></p>
</blockquote>
<p>前两天吃饭的时候听到旁边一桌估计是搜狐或者网易的程序猿在说要是新员工给我面试我就让他写个解数独的Python程序，他二十分钟就能连伪代码加实现一起搞定……我上网一看，解数独这个问题确实挺有趣的，主要是纯凭自己好像很偶尔才能解出一个数独来的样子，于是根据以前学的数据结构的基础和最近新学的Python功底，小试牛刀一下，就使用最简单的回溯方法来实现，我知道百度上其实挺多的，但是说实话那些乱七八糟的代码我也看不太懂，自己想自己写可能思路属于自己，会比较清晰吧。回溯搜索是深度优先搜索（DFS）的一种<br>对于某一个搜索树来说（搜索树是起记录路径和状态判断的作用），回溯和DFS，其主要的区别是，回溯法在求解过程中不保留完整的树结构，而深度优先搜索则记下完整的搜索树。<br>“芬兰数学家因卡拉，花费3个月时间设计出的世界上迄今难度最大的数独游戏，而且它只有一个答案。因卡拉说只有思考能力最快、头脑最聪明的人才能破解这个游戏。”这是英国《每日邮报》2012年6月30日的一篇报道。我接下来就会用这个数独来做示范，说明利用回溯解决这个问题的思路。</p>
<p><img src="/image/sodoku.png" alt="image"></p>
<p>解决数独的关键思想在于找到一个入口点，将解决树一层层撸下去，遇到无法继续生长下去的结点，就往上回溯，回溯之后从上一个结点的其他分支继续往下走，如果没有其他分支则继续往上回溯。<br>先将整个数独矩阵用二维数组存储：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">problem = \</span><br><span class="line">    [</span><br><span class="line">        [<span class="number">8</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">6</span>,<span class="number">8</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">0</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">        [<span class="number">0</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>之后，在解的过程中，由于需要回溯，所以需要把经历过的节点记录下来，我并不知道有没有更好的处理方式，这里用的是栈的存储方式，将经历过的节点存储在solutionStack中，当需要回溯的时候，直接pop掉栈顶的solution，如果解完了，则栈顶就是最后的结果。当经历了一个新的分支，在矩阵中添加了一个新的值，则随之产生一个新的节点，压入栈中。<br>然后，每个节点的数据并不只限于当前的矩阵状态（我其实觉得这里换成一个节点的数据结构会比较好），还包括矩阵中每个点可能的分支，这个栈的压入和弹出是和solutionStack同步的。每当进入新的分支，都需要将这个节点的可能解中修改过的值去掉，这样在往下走并且回溯的时候，就可以回到这个节点的修改后的可能解情况，即刚刚走过的那个分支不会再重复走一遍。<br>主方法：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="atom">import</span> <span class="atom">time</span></span><br><span class="line"><span class="atom">import</span> <span class="atom">copy</span></span><br><span class="line"><span class="atom">def</span> <span class="atom">resolve</span>(<span class="atom">problem</span>):</span><br><span class="line">    <span class="atom">solutionStack</span> = [<span class="atom">problem</span>]</span><br><span class="line">    <span class="atom">tmp</span> = <span class="atom">get_solution_array</span>(<span class="atom">problem</span>)</span><br><span class="line">    <span class="atom">solutionArrayStack</span> = [<span class="atom">tmp</span>]</span><br><span class="line">    # <span class="atom">problem</span> = [[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">    # [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">    <span class="atom">while</span> <span class="number">1</span>:</span><br><span class="line">        # <span class="atom">fetch</span> <span class="atom">the</span> <span class="atom">last</span> <span class="atom">solution</span> <span class="atom">in</span> <span class="atom">solution</span> <span class="atom">stack</span></span><br><span class="line">        <span class="atom">next_item_cord</span> = &#123;&#125;</span><br><span class="line">        <span class="atom">solutionArray</span> = []</span><br><span class="line">        # <span class="atom">print</span> <span class="string">'still '</span>,<span class="atom">len</span>(<span class="atom">solutionStack</span>),<span class="string">'in stack'</span></span><br><span class="line">        <span class="atom">solutionNow</span> = <span class="atom">copy</span>.<span class="atom">deepcopy</span>(<span class="atom">solutionStack</span>[<span class="atom">len</span>(<span class="atom">solutionStack</span>)-<span class="number">1</span>])</span><br><span class="line">        <span class="atom">solutionArray</span> = <span class="atom">solutionArrayStack</span>[<span class="atom">len</span>(<span class="atom">solutionArrayStack</span>)-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="atom">flag</span> = <span class="atom">check_if_need_to_back</span>(<span class="atom">solutionNow</span>,<span class="atom">solutionArray</span>)</span><br><span class="line">        <span class="atom">if</span> <span class="atom">flag</span> <span class="atom">is</span> <span class="name">True</span>:</span><br><span class="line">            # <span class="atom">print</span> <span class="string">'pop!'</span></span><br><span class="line">            <span class="atom">solutionArrayStack</span>.<span class="atom">pop</span>()</span><br><span class="line">            <span class="atom">solutionStack</span>.<span class="atom">pop</span>()</span><br><span class="line">        <span class="atom">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="atom">next_item_cord</span> = <span class="atom">get_first_possible_item</span>(<span class="atom">solutionArray</span>)</span><br><span class="line">            <span class="atom">if</span> <span class="atom">next_item_cord</span> == <span class="name">False</span>:</span><br><span class="line">                <span class="atom">break</span></span><br><span class="line">            # <span class="atom">print</span> <span class="string">'next_item_cord:'</span>,<span class="atom">next_item_cord</span></span><br><span class="line">            <span class="atom">next_item_array</span> = <span class="atom">solutionArray</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]]</span><br><span class="line">            <span class="atom">solutionNow</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]]=<span class="atom">next_item_array</span>[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="atom">solutionArray_tmp</span> = <span class="atom">get_solution_array</span>(<span class="atom">solutionNow</span>)</span><br><span class="line">            <span class="atom">if</span> <span class="atom">solutionArray</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]].<span class="atom">count</span>(<span class="atom">solutionNow</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]])&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="atom">solutionArray</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]].<span class="atom">remove</span>(<span class="atom">solutionNow</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]])</span><br><span class="line">            <span class="atom">solutionStack</span>.<span class="atom">append</span>(<span class="atom">solutionNow</span>)</span><br><span class="line">            <span class="atom">solutionArrayStack</span>.<span class="atom">append</span>(<span class="atom">solutionArray_tmp</span>)</span><br><span class="line">    <span class="atom">for</span> <span class="atom">i</span> <span class="atom">in</span> <span class="atom">range</span>(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">            <span class="atom">print</span> <span class="atom">solutionStack</span>[<span class="atom">len</span>(<span class="atom">solutionStack</span>)-<span class="number">1</span>][<span class="atom">i</span>]</span><br></pre></td></tr></table></figure>
<p>在开始循环之前，需要先获得初始状态的分支情况，因此独立的获取分支状况的方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_solution_array</span><span class="params">(problem)</span>:</span></span><br><span class="line">    startTime=time.time()</span><br><span class="line">    tmp = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">        tmp_line_array = []</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># print '['+bytes(i)+','+bytes(j)+']: '+ bytes(problem[i][j])</span></span><br><span class="line">            <span class="keyword">if</span> problem[i][j]==<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># no value, get possible value array</span></span><br><span class="line">                tmp_value = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">                <span class="comment"># remove the existed value in line</span></span><br><span class="line">                <span class="keyword">for</span> tmp_j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> problem[i][tmp_j]!=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> problem[i][tmp_j] <span class="keyword">in</span> tmp_value:</span><br><span class="line">                            tmp_value.remove(problem[i][tmp_j])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># remove the existed value in column</span></span><br><span class="line">                <span class="keyword">for</span> tmp_i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> problem[tmp_i][j]!=<span class="number">0</span>:</span><br><span class="line">                        <span class="keyword">if</span> problem[tmp_i][j] <span class="keyword">in</span> tmp_value:</span><br><span class="line">                            tmp_value.remove(problem[tmp_i][j])</span><br><span class="line"></span><br><span class="line">                <span class="comment"># remove the existed value in the rectangle</span></span><br><span class="line">                <span class="keyword">for</span> x <span class="keyword">in</span> range(i/<span class="number">3</span>*<span class="number">3</span>,i/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">                    <span class="keyword">for</span> y <span class="keyword">in</span> range(j/<span class="number">3</span>*<span class="number">3</span>,j/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>):</span><br><span class="line">                        <span class="keyword">if</span> problem[x][y]!=<span class="number">0</span>:</span><br><span class="line">                            <span class="keyword">if</span> problem[x][y] <span class="keyword">in</span> tmp_value:</span><br><span class="line">                                tmp_value.remove(problem[x][y])</span><br><span class="line"></span><br><span class="line">                tmp_line_array.append(tmp_value)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp_line_array.append([])</span><br><span class="line">        tmp.append(tmp_line_array)</span><br><span class="line">        <span class="comment">#print tmp_line_array</span></span><br><span class="line">    <span class="comment"># print tmp</span></span><br><span class="line">    endTime=time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"get_solution_array! Time consuming: "</span> + <span class="string">"%.4f"</span> % (endTime-startTime) + <span class="string">" Seconds"</span></span><br><span class="line">    <span class="keyword">return</span> tmp</span><br></pre></td></tr></table></figure>
<p>这里需要说一点，其实每次压栈的时候节点状态做局部更新就好了，这样会减少很大的计算量，这个优化会在之后进行。每次到了新节点都要寻找下一个修改的坐标，这里就寻找的是下一个可能解最少的元素作为下一个节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_possible_item</span><span class="params">(solution_array)</span>:</span></span><br><span class="line">    startTime=time.time()</span><br><span class="line">    is_finished = <span class="keyword">True</span></span><br><span class="line">    shortest_item_length = <span class="number">9</span></span><br><span class="line">    shortest_item_x = <span class="number">0</span></span><br><span class="line">    shortest_item_y = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">            tmp_length = len(solution_array[i][j])</span><br><span class="line">            <span class="keyword">if</span> tmp_length!=<span class="number">0</span>:</span><br><span class="line">                is_finished = <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> tmp_length&lt;shortest_item_length:</span><br><span class="line">                    shortest_item_length = tmp_length</span><br><span class="line">                    shortest_item_x = i</span><br><span class="line">                    shortest_item_y = j</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y</span></span><br><span class="line">    endTime=time.time()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"get_first_possible_item! Time consuming: "</span> + <span class="string">"%.4f"</span> % (endTime-startTime) + <span class="string">" Seconds"</span></span><br><span class="line">    <span class="keyword">if</span> is_finished:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">'x'</span>:shortest_item_x,<span class="string">'y'</span>:shortest_item_y&#125;</span><br></pre></td></tr></table></figure>
<p>补充一个判断是否需要回溯的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_if_need_to_back</span><span class="params">(solutionNow,solutionArray)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> len(solutionArray[i][j]) == <span class="number">0</span> <span class="keyword">and</span> solutionNow[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>最后的输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">Finished! Time consuming: <span class="number">5.2055</span> Seconds</span><br></pre></td></tr></table></figure>
<p>这里的一处细节是最后的运行时间是5.2055秒，这相对于其他人的实现方式慢了一些，我在get_solution_array中用来判断所获取的值是否在可能解的候选数组中的时候，之前用的是list.count(object)这个方法来判断，后来改成了in，事实证明如果使用.count的话总消耗大概在5.6秒左右，会比in多出0.4S。</p>
<p>恩。我改成局部更新数据了。新的获取可能解的方法：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">def <span class="function"><span class="title">get_resolution_array_new</span><span class="params">(solutionArray,x,y,value)</span></span>:</span><br><span class="line">    <span class="keyword">for</span> tmp_j <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>)</span></span>:</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">in</span> solutionArray[x][tmp_j]:</span><br><span class="line">            solutionArray[x][tmp_j].<span class="function"><span class="title">remove</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">for</span> tmp_i <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">9</span>,<span class="number">1</span>)</span></span>:</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">in</span> solutionArray[tmp_i][y]:</span><br><span class="line">            solutionArray[tmp_i][y].<span class="function"><span class="title">remove</span><span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">for</span> tmp_i <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(x/<span class="number">3</span>*<span class="number">3</span>,x/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>)</span></span>:</span><br><span class="line">        <span class="keyword">for</span> tmp_j <span class="keyword">in</span> <span class="function"><span class="title">range</span><span class="params">(y/<span class="number">3</span>*<span class="number">3</span>,y/<span class="number">3</span>*<span class="number">3</span>+<span class="number">3</span>)</span></span>:</span><br><span class="line">            <span class="keyword">if</span> value <span class="keyword">in</span> solutionArray[tmp_i][tmp_j]:</span><br><span class="line">                solutionArray[tmp_i][tmp_j].<span class="function"><span class="title">remove</span><span class="params">(value)</span></span></span><br><span class="line">    return solutionArray</span><br></pre></td></tr></table></figure>
<p>将主方法中38行代码改为：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">solutionArray_tmp = copy.<span class="function"><span class="title">deepcopy</span><span class="params">(solutionArray)</span></span></span><br><span class="line">solutionArray_tmp = <span class="function"><span class="title">get_resolution_array_new</span><span class="params">(solutionArray_tmp,next_item_cord[<span class="string">'x'</span>],next_item_cord[<span class="string">'y'</span>],next_item_array[<span class="number">0</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>最后的结果如下……也不咋地嘛，只是快了0.4S……看来还有优化空间吧</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">Finished! Time consuming: <span class="number">4.8577</span> Seconds</span><br></pre></td></tr></table></figure>
<p>–&gt;继续补充<br>早上起来想了想又监控了一下，发现最主要耗时的还是在走的分支数量上，如果按照每次往下都默认走最左边的分支，那么前进会操作12000多次，回溯也差不多这个数，这是导致时间增大的主要原因。我没有想好如何在几个分支要选择的时候选择最优分支……毕竟我觉得去选择最优分支也要消耗时间，考虑太多意义不大……于是我就简单的尝试了一下随机分支，当程序运行到一个节点需要继续往下分支的时候随机选择一个分支，随机就用的最简单的随机方法，结果效果惊人，最快的时候可以达到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">Finished! Time consuming: <span class="number">1.8991</span> Seconds</span><br></pre></td></tr></table></figure>
<p>当然由于采用了随机，所以时间并不稳定……在这种最优解的情况下只要前进5000次就能到达最终解。如何有一个稳定的最优算法也许永远会是个谜吧。<br>随机选择分支的代码如下：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><span class="line"><span class="atom">next_item_array</span> = <span class="atom">solutionArray</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]]</span><br><span class="line">                <span class="atom">next_item</span> = <span class="atom">next_item_array</span>[<span class="atom">randint</span>(<span class="number">0</span>,<span class="atom">len</span>(<span class="atom">next_item_array</span>)-<span class="number">1</span>)]</span><br><span class="line">                <span class="atom">solutionNow</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]] = <span class="atom">next_item</span></span><br><span class="line"></span><br><span class="line">                # <span class="atom">solutionArray_tmp</span> = <span class="atom">get_solution_array</span>(<span class="atom">solutionNow</span>)</span><br><span class="line">                <span class="atom">solutionArray_tmp</span> = <span class="atom">copy</span>.<span class="atom">deepcopy</span>(<span class="atom">solutionArray</span>)</span><br><span class="line">                <span class="atom">solutionArray_tmp</span> = <span class="atom">self</span>.<span class="atom">get_resolution_array_new</span>(<span class="atom">solutionArray_tmp</span>, <span class="atom">next_item_cord</span>[<span class="string">'x'</span>], <span class="atom">next_item_cord</span>[<span class="string">'y'</span>],</span><br><span class="line">                                                             <span class="atom">next_item</span>)</span><br><span class="line">                <span class="atom">if</span> <span class="atom">next_item</span> <span class="atom">in</span> <span class="atom">solutionArray</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]]:</span><br><span class="line">                    <span class="atom">solutionArray</span>[<span class="atom">next_item_cord</span>[<span class="string">'x'</span>]][<span class="atom">next_item_cord</span>[<span class="string">'y'</span>]].<span class="atom">remove</span>(</span><br><span class="line">                        <span class="atom">next_item</span>)</span><br></pre></td></tr></table></figure>
<p>–&gt;又找出一个问题<br>在获取下一个最优节点的过程中，没有算上当前矩阵中的那个值，所以会导致一个点连续的用了两次，最后可能还要回溯，所以修改了一下代码后，效率继续提升：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_first_possible_item</span><span class="params">(self, solution_array, solutionNow = None)</span>:</span></span><br><span class="line">        is_finished = <span class="keyword">True</span></span><br><span class="line">        shortest_item_length = <span class="number">9</span></span><br><span class="line">        shortest_item_x = <span class="number">0</span></span><br><span class="line">        shortest_item_y = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">9</span>, <span class="number">1</span>):</span><br><span class="line">                tmp_length = len(solution_array[i][j])</span><br><span class="line">                <span class="keyword">if</span> tmp_length != <span class="number">0</span>:</span><br><span class="line">                    is_finished = <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">if</span> solutionNow[i][j] != <span class="number">0</span>:</span><br><span class="line">                        tmp_length += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> tmp_length &lt; shortest_item_length:</span><br><span class="line">                        shortest_item_length = tmp_length</span><br><span class="line">                        shortest_item_x = i</span><br><span class="line">                        shortest_item_y = j</span><br><span class="line"></span><br><span class="line">        <span class="comment"># print 'shortest item is:',shortest_item_length,shortest_item_x,shortest_item_y</span></span><br><span class="line">        <span class="keyword">if</span> is_finished:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="string">'x'</span>: shortest_item_x, <span class="string">'y'</span>: shortest_item_y&#125;</span><br></pre></td></tr></table></figure>
<p>在这种情况下，如果不用随机选择节点的方法，前进的次数稳定在9100次左右，比之前少了3000次左右，因此速度也提升到了3.6S，比4.8S提升了1.2S左右，变化显著。然后，尝试了一下随机选择节点的方式，目前计算出的最优解精确的是4142次，耗时1.6262S。另外，如何选择最优节点，继续减少解的路径应该是最终的优化办法了吧……</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[<span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">9</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>]</span><br><span class="line">[<span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line">total forward: <span class="number">4142</span></span><br><span class="line">Finished! Time consuming: <span class="number">1.6262</span> Seconds</span><br></pre></td></tr></table></figure>]]></content>
    <summary type="html">
    <![CDATA[<blockquote>
<p>本文附带项目Github仓库地址，随手star是个好习惯：<br><a href="https://github.com/SergioChan/Python-Sudoku" target="_blank" rel="external">https:]]>
    </summary>
    
      <category term="python" scheme="http://sergiochan.github.io/tags/python/"/>
    
      <category term="python数独， 深度优先搜索" scheme="http://sergiochan.github.io/tags/python%E6%95%B0%E7%8B%AC%EF%BC%8C-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
      <category term="Python学习" scheme="http://sergiochan.github.io/categories/Python%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[怎么设计和实现一个Newsfeed系统]]></title>
    <link href="http://sergiochan.github.io/2015/04/01/%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AANewsfeed%E7%B3%BB%E7%BB%9F/"/>
    <id>http://sergiochan.github.io/2015/04/01/怎么设计和实现一个Newsfeed系统/</id>
    <published>2015-04-01T01:14:52.000Z</published>
    <updated>2015-12-19T01:19:28.000Z</updated>
    <content type="html"><![CDATA[<p>也是拖了好久，才开始写这篇关于Newsfeed系统设计与实现的介绍。今天已经把新产品需要的第一个版本的Newsfeed系统部署完了，所以对整个过程也有了清晰的了解。我希望能够通过我研究，设计，实现和部署这个系统的过程，来展示Facebook，Twitter和朋友圈的基本实现原理大概是什么样的。<br>首先，想要实现类似Facebook的信息流的系统，如果使用最简单的脚本语言加Mysql的实现方式也是未尝不可，只是当一个系统的容量到一定级别之后，简单的技术就会变得难以满足系统的需求了。特别是在实际需求中，feed所在的表可能会经历超大并发的读写，而且由于feed的特殊性——例如Facebook，twitter，这些feed其实都只是一个简单的动态信息，而并非一个完整的对象信息，因此关系型数据库对于Newsfeed系统来说并不是最首选的方案。Feed的实际需求还有：</p>
<blockquote>
<ul>
<li>1.用户需要频繁查询自己和自己好友产生的动态集合。</li>
<li>2.用户需要频繁的查询自己或其他用户产生的动态的子集。</li>
</ul>
<p>第一条需求远大于第二条，即刷朋友圈的次数远大于查看用户相册的次数。  </p>
</blockquote>
<p>如果采用关系型数据库，那么第一个需求的实现应该是先从好友表中获取该用户的好友ID，然后通过好友ID在这个表中查询所有的数据，并通过时间排序分页返回之类，这实际上在数据库操作中遍历了大量其他无用的信息，而且当表的容量增大，如果不采用高效的分表或索引，这个操作的代价将会更大。而第二个需求，也是存在同样的问题，当1000个用户分别查看1个用户的timeline时，其中有999次数据库操作是浪费的，因此在Newsfeed的系统中采用Nosql的数据库是更加明智的方案。<br>在开始，选择redis还是cassandra着实让我犹豫了一阵，这篇文章彻底打开了我的思路：</p>
<p><a href="http://www.csdn.net/article/2013-11-07/2817430-design-decisions-for-scaling-your-high-traffic-feeds" target="_blank" rel="external">http://www.csdn.net/article/2013-11-07/2817430-design-decisions-for-scaling-your-high-traffic-feeds</a></p>
<p>这是一个国外时尚网站和instagram的发展经验。</p>
<p>Fashiolista和Instagram都经历了从Redis开始，然后转战Cassandra的过程。笔者之所以会推荐从Redis开始是因为Redis更容易启动和维持。<br>然而Redis存在一定的限制，所有的数据需要被存储在RAM中，成本很高。另外，Redis不支持分片，这意味着你必须在结点间分片（Twemproxy 是一个不错的选择），这种分片很容易，但是添加和删除节点时的数据处理很复杂。当然你可以将Redis作为缓存，然后重新访问数据库，来克服这个限制。但 是随着访问数据库的成本越来越高，笔者建议还是用Cassandra代替Redis。<br>Redis是一种部署比较容易的Nosql数据库，它基于Key-value存储，数据全部存在内存中，访问速度和并发量着实很让人吃惊。对于各种软件中的Notification系统和这种没到Facebook,Twitter那种量级的Newsfeed系统，redis应该是性价比最高的一种数据库解决办法了：它的集群配置比较方便，配置文件比较简单（即使这样还是费了很大的劲，配置文件的详解还是有的，所以配置起来还算方便：<a href="http://blog.csdn.net/neubuffer/article/details/17003909" target="_blank" rel="external">http://blog.csdn.net/neubuffer/article/details/17003909</a><br>），并发量不用怎么处理就可以轻松过10w+（<a href="http://my.oschina.net/pblack/blog/102394" target="_blank" rel="external">http://my.oschina.net/pblack/blog/102394</a>）</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ numactl -C <span class="number">6</span> ./redis-benchmark -q -n <span class="number">100000</span> -d <span class="number">256</span> </span><br><span class="line">PING (inline): <span class="number">145137.88</span> requests per <span class="keyword">second</span> </span><br><span class="line">PING: <span class="number">144717.80</span> requests per <span class="keyword">second</span> MSET (<span class="number">10</span> <span class="built_in">keys</span>): <span class="number">65487.89</span> requests per <span class="keyword">second</span> </span><br><span class="line">SET: <span class="number">142653.36</span> requests per <span class="keyword">second</span> </span><br><span class="line">GET: <span class="number">142450.14</span> requests per <span class="keyword">second</span> </span><br><span class="line">INCR: <span class="number">143061.52</span> requests per <span class="keyword">second</span> </span><br><span class="line">LPUSH: <span class="number">144092.22</span> requests per <span class="keyword">second</span> </span><br><span class="line">LPOP: <span class="number">142247.52</span> requests per <span class="keyword">second</span> </span><br><span class="line">SADD: <span class="number">144717.80</span> requests per <span class="keyword">second</span> </span><br><span class="line">SPOP: <span class="number">143678.17</span> requests per <span class="keyword">second</span> </span><br><span class="line">LPUSH (again, <span class="operator">in</span> order <span class="built_in">to</span> bench LRANGE): <span class="number">143061.52</span> requests per <span class="keyword">second</span> </span><br><span class="line">LRANGE (<span class="keyword">first</span> <span class="number">100</span> elements): <span class="number">29577.05</span> requests per <span class="keyword">second</span> </span><br><span class="line">LRANGE (<span class="keyword">first</span> <span class="number">300</span> elements): <span class="number">10431.88</span> requests per <span class="keyword">second</span> </span><br><span class="line">LRANGE (<span class="keyword">first</span> <span class="number">450</span> elements): <span class="number">7010.66</span> requests per <span class="keyword">second</span> </span><br><span class="line">LRANGE (<span class="keyword">first</span> <span class="number">600</span> elements): <span class="number">5296.61</span> requests per <span class="keyword">second</span></span><br></pre></td></tr></table></figure>
<p>存储的问题解决了，接下来就是主体的服务了。目前最主流的开源feed系统应该就是上面引用的文章所说的feedly，也就是现在改名为stream framework的一个开源项目，其源代码在github上面可以被搜到。目前开源的版本只有python的，其他语言的如果要实现必须去官网购买付费的服务。</p>
<ul>
<li>非开源的：<a href="http://getstream.io/get_started/" target="_blank" rel="external">http://getstream.io/get_started/</a></li>
<li>开源的wiki地址：<a href="https://stream-framework.readthedocs.org/en/latest/installation.html" target="_blank" rel="external">https://stream-framework.readthedocs.org/en/latest/installation.html</a></li>
</ul>
<p>直接用pip安装方式就可以安装好对python的支持。</p>
<p>根据框架要求安装好几个python的库的支持之后，就可以参照提供的这个示例来设计整个系统了<br><a href="https://github.com/tbarbugli/stream_framework_example" target="_blank" rel="external">https://github.com/tbarbugli/stream_framework_example</a><br>这个框架的原理是使用框架本身提供的Activity类和它的结构，用户根据需求自定义verb，即动态的动作（不知道这么翻译行不行），然后根据使用的数据库形式派生自定义的feed类，确定自定义feed的格式和单个feed的数据上限。这个框架的核心在于Manager类，用户需要继承出一个子类，来实现基本的feed操作。例如添加，删除，分发。（修改feed貌似还不支持）<br>每个feed在数据库中的存在形式即一个key，对应的数据格式是sorted set，这是一个有序集合，每一个元素都有一个排序用的score，而这个score在这就是时间戳。我在自己设计实现相册的时候，也使用了这种设计思想。每一个有序集合里，只存着该feed所拥有的动态的activityId，而动态的基本信息会经过哈希后存在全局的10个hashes中。<br>根据上面提出的两个需求，每个用户就需要有两个feed，一个是每个用户自己的feed，也称为每个用户的timeline，一个是每个用户关注的用户的动态集合，即每个用户的feed，这个feed的维护是通过每次该用户关注的用户发布动态时的分发来进行的。当然，后来加上的相册不在这个框架提供的范围内，我给每个用户又添加了一个存储所有image的key，也是存储每个image唯一的id，再将具体的image信息存储在全局的hashes中。<br>按照以上设计实现出来的系统中，当一个用户想要查看自己的feed，他就只需要直接查询自己的feed的这个key中的信息，当一个用户想要查看自己或某人的timeline的时候，他也只需要查询这个timeline中的信息即可，这些操作都是简单地GET，而不会像关系型数据库需要广大的遍历。当然，这个设计的关键之处就在于如何维护这些key中的内容。<br>Redis的官网有详细的博客和操作介绍：<a href="http://redis.io" target="_blank" rel="external">http://redis.io</a></p>
<p>说完了存储，就是最关键的分发。Stream framework的关键就在于利用celery异步队列处理机制实现了动态的分发。它默认必须安装django-celery来支持异步处理分发。<br>Django-celery是celery在django的一个支持版本。它是独立于django的一个异步队列处理框架，简单地说就是他有一个队列，有N个worker（由用户自定义）等待执行队列中的task和一个或多个django app，也就是task的发送方贯穿而成。因为是django的版本，所以它的task实际上都是在django中预先编译好的。在stream framework中，用来实现分发的task就包括了几个具体的task，如果要自己写一些定向分发动态或notification，djcelery是必须要熟悉和掌握的。<br>我们可能想要实现类似微信朋友圈推广那种下沉式feed，就要通过定向分发将这个动态分发到指定用户的feed中去，而这个分发的工作量是极其大的，如果要给前端的管理平台等提供一个发布的接口，我们必须要用djcelery在后台运行的一个worker来不断的执行这个task，然后先将http请求返回给用户，而这个task的执行结果可以通过设置celery的backend存储目标来输出。<br>具体的celery设置可以参考：<br><a href="http://docs.celeryproject.org/en/latest/django/" target="_blank" rel="external">http://docs.celeryproject.org/en/latest/django/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>也是拖了好久，才开始写这篇关于Newsfeed系统设计与实现的介绍。今天已经把新产品需要的第一个版本的Newsfeed系统部署完了，所以对整个过程也有了清晰的了解。我希望能够通过我研究，设计，实现和部署这个系统的过程，来展示Facebook，Twitter和朋友圈的基本实现]]>
    </summary>
    
      <category term="Newsfeed" scheme="http://sergiochan.github.io/tags/Newsfeed/"/>
    
      <category term="celery" scheme="http://sergiochan.github.io/tags/celery/"/>
    
      <category term="djcelery" scheme="http://sergiochan.github.io/tags/djcelery/"/>
    
      <category term="redis" scheme="http://sergiochan.github.io/tags/redis/"/>
    
      <category term="stream framework" scheme="http://sergiochan.github.io/tags/stream-framework/"/>
    
      <category term="Python学习笔记" scheme="http://sergiochan.github.io/categories/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[[UIColor colorWithRed: green: blue: alpha:] 的正确用法]]></title>
    <link href="http://sergiochan.github.io/2015/02/02/UIColor-colorWithRed-green-blue-alpha-%E7%9A%84%E6%AD%A3%E7%A1%AE%E7%94%A8%E6%B3%95/"/>
    <id>http://sergiochan.github.io/2015/02/02/UIColor-colorWithRed-green-blue-alpha-的正确用法/</id>
    <published>2015-02-02T13:37:10.000Z</published>
    <updated>2015-12-18T13:13:14.000Z</updated>
    <content type="html"><![CDATA[<p>[UIColor colorWithRed: green: blue: alpha:] 颜色值范围都是在0.0~1.0之间的，并不是我们误认为的0~255。</p>
<p>正确用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[UIColor colorWithRed:<span class="number">240.0</span>/<span class="number">255</span> green:<span class="number">240.0</span>/<span class="number">255</span> blue:<span class="number">240.0</span>/<span class="number">255</span> alpha:<span class="number">1.0</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>colorWithRed:green:blue:alpha:<br>Creates and returns a color object using the specified opacity and RGB component values.</p>
<p>Declaration<br>OBJECTIVE-C</p>
<ul>
<li>(UIColor *)colorWithRed:(CGFloat)red<br>green:(CGFloat)green<br>blue:(CGFloat)blue<br>alpha:(CGFloat)alpha</li>
</ul>
<p>Parameters</p>
<p>red</p>
<p>The red component of the color object, specified as a value from 0.0 to 1.0.</p>
<p>green</p>
<p>The green component of the color object, specified as a value from 0.0 to 1.0.</p>
<p>blue</p>
<p>The blue component of the color object, specified as a value from 0.0 to 1.0.</p>
<p>alpha</p>
<p>The opacity value of the color object, specified as a value from 0.0 to 1.0.</p>
<p>Return Value</p>
<p>The color object. The color information represented by this object is in the device RGB colorspace.</p>
<p>Discussion<br>Values below 0.0 are interpreted as 0.0, and values above 1.0 are interpreted as 1.0.</p>
<p>Import Statement<br>Availability<br>Available in iOS 2.0 and later.</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>[UIColor colorWithRed: green: blue: alpha:] 颜色值范围都是在0.0~1.0之间的，并不是我们误认为的0~255。</p>
<p>正确用法：</p>
<figure class="highlight cpp"><table><tr>]]>
    </summary>
    
      <category term="UIColor" scheme="http://sergiochan.github.io/tags/UIColor/"/>
    
      <category term="iOS菜鸟心得" scheme="http://sergiochan.github.io/categories/iOS%E8%8F%9C%E9%B8%9F%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP图片处理 透明水印的处理和添加]]></title>
    <link href="http://sergiochan.github.io/2014/12/26/PHP%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86-%E9%80%8F%E6%98%8E%E6%B0%B4%E5%8D%B0%E7%9A%84%E5%A4%84%E7%90%86%E5%92%8C%E6%B7%BB%E5%8A%A0/"/>
    <id>http://sergiochan.github.io/2014/12/26/PHP图片处理-透明水印的处理和添加/</id>
    <published>2014-12-26T01:11:25.000Z</published>
    <updated>2015-12-18T13:13:14.000Z</updated>
    <content type="html"><![CDATA[<p>最近玩了下PHP的图片处理，实现了一个给图片添加水印或者是重叠两张图片的功能，把自己的解决过程记录下来。</p>
<p>首先我需要将图片resize到640*480的尺寸，重绘的代码如下：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="variable">$thumb</span> = imagecreatetruecolor(<span class="variable">$newwidth</span>, <span class="variable">$newheight</span>);</span><br><span class="line"><span class="variable">$source</span> = imagecreatefromjpeg(<span class="variable">$filename</span>);</span><br><span class="line">imagecopyresampled(<span class="variable">$thumb</span>, <span class="variable">$source</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="variable">$newwidth</span>, <span class="variable">$newheight</span>, <span class="variable">$width</span>, <span class="variable">$height</span>);</span><br><span class="line">imagejpeg(<span class="variable">$thumb</span>, <span class="variable">$filename</span>);</span><br></pre></td></tr></table></figure>
<p>在这段重绘的代码里，包含了几个很基本的东西：</p>
<p>第一个是imagecreatetruecolor和imagecreate<br>用imagecreatetruecolor(int x,int y)建立的是一幅大小为x和y的黑色图像(默认为黑色)，如想改变背景颜色则需要用填充颜色函数imagefill($img,0,0,$color)，imagecreate 新建一个空白图像资源，用imagecolorAllocate()添加背景色：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="variable">$img</span> = imagecreatetruecolor(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="variable">$color</span> = imagecolorAllocate(<span class="variable">$img</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">imagefill(<span class="variable">$img</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="variable">$color</span>);</span><br><span class="line">header(<span class="string">'content-type:image/jpeg'</span>);</span><br><span class="line">imagejpeg(<span class="variable">$img</span>);</span><br><span class="line"><span class="variable">$img</span> = imagecreate(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line"><span class="variable">$color</span> = imagecolorallocate(<span class="variable">$img</span>,<span class="number">200</span>,<span class="number">200</span>,<span class="number">200</span>);</span><br><span class="line">header(<span class="string">'content-type:image/jpeg'</span>);</span><br><span class="line">imagejpeg(<span class="variable">$img</span>);</span><br></pre></td></tr></table></figure>
<p>第二个是imagecreatefromjpeg，这个是从图片文件创建一个新图像。<br>支持下面这些格式的图片文件。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> imagecreatefrompng (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromgif (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromjpeg (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromwbmp (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromxbm (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromxpm (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromgd (<span class="variable">$filename</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> imagecreatefromgd2 (<span class="variable">$filename</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第三个是imagecopyresampled，这个函数在裁剪，缩放图像时都特别有用：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line">* (PHP <span class="number">4</span> &amp;gt;= <span class="number">4.0</span>.<span class="number">6</span>, PHP <span class="number">5</span>)</span><br><span class="line">* Copy and resize part <span class="keyword">of</span> an image with resampling</span><br><span class="line">* @link http://php.net/manual/en/<span class="keyword">function</span>.imagecopyresampled.php</span><br><span class="line">* @param resource <span class="variable">$dst</span>_image</span><br><span class="line">* @param resource <span class="variable">$src</span>_image</span><br><span class="line">* @param int <span class="variable">$dst</span>_x</span><br><span class="line">* x-coordinate <span class="keyword">of</span> destination point.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$dst</span>_y</span><br><span class="line">* y-coordinate <span class="keyword">of</span> destination point.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$src</span>_x</span><br><span class="line">* x-coordinate <span class="keyword">of</span> source point.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$src</span>_y</span><br><span class="line">* y-coordinate <span class="keyword">of</span> source point.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$dst</span>_w</span><br><span class="line">* Destination width.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$dst</span>_h</span><br><span class="line">* Destination height.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$src</span>_w</span><br><span class="line">* Source width.</span><br><span class="line">*</span><br><span class="line">* @param int <span class="variable">$src</span>_h</span><br><span class="line">* Source height.</span><br><span class="line">*</span><br><span class="line">* @<span class="keyword">return</span> bool <span class="literal">true</span> on success or <span class="literal">false</span> on failure.</span><br><span class="line">*/</span><br><span class="line"><span class="keyword">function</span> imagecopyresampled (<span class="variable">$dst</span>_image, <span class="variable">$src</span>_image, <span class="variable">$dst</span>_x, <span class="variable">$dst</span>_y, <span class="variable">$src</span>_x, <span class="variable">$src</span>_y, <span class="variable">$dst</span>_w, <span class="variable">$dst</span>_h, <span class="variable">$src</span>_w, <span class="variable">$src</span>_h) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第四个是imagejpeg，这个函数如果不提供第二个filename的参数，会将图片文件直接输出出来，加上了这个参数就会按照方法名里的文件格式输出到文件中去。返回的是BOOL值。</p>
<p>接下去就是加上水印的这个函数了，我添加了一个newwidth的参数，是希望在进入这个函数前计算出需要的水印大小，传入函数，这样生成的水印大小就会不一样了，可以根据不同的需要变化。</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> mark_pic(<span class="variable">$background</span>, <span class="variable">$waterpic</span>, <span class="variable">$x</span>, <span class="variable">$y</span>, <span class="variable">$new</span>_width)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$back</span> = imagecreatefromjpeg(<span class="variable">$background</span>);</span><br><span class="line"><span class="variable">$water</span> = imagecreatefrompng(<span class="variable">$waterpic</span>);</span><br><span class="line"><span class="variable">$w</span>_w = imagesx(<span class="variable">$water</span>);</span><br><span class="line"><span class="variable">$w</span>_h = imagesy(<span class="variable">$water</span>);</span><br><span class="line">imagesavealpha(<span class="variable">$water</span>, true);</span><br><span class="line">if (<span class="variable">$new</span>_width != <span class="variable">$w</span>_w)</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$new</span>_height = <span class="variable">$w</span>_h * (<span class="variable">$new</span>_width / <span class="variable">$w</span>_w);</span><br><span class="line"><span class="variable">$thumb</span> = imagecreatetruecolor(<span class="variable">$new</span>_width, <span class="variable">$new</span>_height);</span><br><span class="line"><span class="variable">$c</span> = imagecolorallocatealpha(<span class="variable">$thumb</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">127</span>);</span><br><span class="line">//拾取一个完全透明的颜色</span><br><span class="line">imagealphablending(<span class="variable">$thumb</span>, false);</span><br><span class="line">//关闭混合模式，以便透明颜色能覆盖原画布</span><br><span class="line">imagefill(<span class="variable">$thumb</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="variable">$c</span>); //填充</span><br><span class="line">imagesavealpha(<span class="variable">$thumb</span>, true); //设置保存PNG时保留透明通道信息</span><br><span class="line">imagecopyresampled(<span class="variable">$thumb</span>, <span class="variable">$water</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="variable">$new</span>_width, <span class="variable">$new</span>_height, <span class="variable">$w</span>_w, <span class="variable">$w</span>_h);</span><br><span class="line">imagepng(<span class="variable">$thumb</span>, <span class="variable">$waterpic</span>);</span><br><span class="line">imagedestroy(<span class="variable">$water</span>);</span><br><span class="line"><span class="variable">$water</span> = imagecreatefrompng(<span class="variable">$waterpic</span>);</span><br><span class="line"><span class="variable">$w</span>_w = imagesx(<span class="variable">$water</span>);</span><br><span class="line"><span class="variable">$w</span>_h = imagesy(<span class="variable">$water</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span>_w = imagesx(<span class="variable">$back</span>);</span><br><span class="line"><span class="variable">$b</span>_h = imagesy(<span class="variable">$back</span>);</span><br><span class="line">imagecopy(<span class="variable">$back</span>, <span class="variable">$water</span>, <span class="variable">$x</span>, <span class="variable">$y</span> - <span class="variable">$w</span>_h , <span class="number">0</span>, <span class="number">0</span>, <span class="variable">$w</span>_w, <span class="variable">$w</span>_h);</span><br><span class="line">imagejpeg(<span class="variable">$back</span>, <span class="string">"./files/test.jpg"</span>);</span><br><span class="line">imagedestroy(<span class="variable">$back</span>);</span><br><span class="line">imagedestroy(<span class="variable">$water</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数里，最重要的一个事情其实在于重绘一个具有透明通道的图像。如果使用imagecreate，透明通道就会被消灭掉，因此我最后只能采用了以上的办法，通过imagecreatetruecolor，往上面覆盖一个完全透明的颜色，来保留图片的透明通道，这对于添加水印这个功能应该是至关重要的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近玩了下PHP的图片处理，实现了一个给图片添加水印或者是重叠两张图片的功能，把自己的解决过程记录下来。</p>
<p>首先我需要将图片resize到640*480的尺寸，重绘的代码如下：</p>
<figure class="highlight xquery"><tabl]]>
    </summary>
    
      <category term="PHP图片处理，水印" scheme="http://sergiochan.github.io/tags/PHP%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%EF%BC%8C%E6%B0%B4%E5%8D%B0/"/>
    
      <category term="PHP大神养成" scheme="http://sergiochan.github.io/categories/PHP%E5%A4%A7%E7%A5%9E%E5%85%BB%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Ubuntu下重置MySQL的root密码]]></title>
    <link href="http://sergiochan.github.io/2014/12/12/Ubuntu%E4%B8%8B%E9%87%8D%E7%BD%AEMySQL%E7%9A%84root%E5%AF%86%E7%A0%81/"/>
    <id>http://sergiochan.github.io/2014/12/12/Ubuntu下重置MySQL的root密码/</id>
    <published>2014-12-12T02:10:45.000Z</published>
    <updated>2015-12-18T13:13:14.000Z</updated>
    <content type="html"><![CDATA[<p>sudo vi /etc/mysql/my.cnf，在[mysqld]段中加入一行“skip-grant-tables”<br>具体环境中可能my.cnf已经存在且在其他目录，记得要找到有效的my.cnf配置文件路径</p>
<p>sudo service mysql restart，重启mySQL服务<br>具体参考实际的重启MySQL的命令</p>
<p>sudo mysql -u root -p mysql，用空密码进入mysql管理命令行</p>
<p>(进入mysql,或者用use mysql指令)</p>
<p>update user set password=PASSWORD(“123”) where user=’root’;，把密码重置为123</p>
<p>(注意，如果是表中没有的用户名，使用insert)</p>
<p>quit，退出数据库管理</p>
<p>sudo vim /etc/mysql/my.cnf，把刚才加入的那一行“skip-grant-tables”注释或删除</p>
<p>sudo service mysql restart，OK，搞定！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>sudo vi /etc/mysql/my.cnf，在[mysqld]段中加入一行“skip-grant-tables”<br>具体环境中可能my.cnf已经存在且在其他目录，记得要找到有效的my.cnf配置文件路径</p>
<p>sudo service mysql re]]>
    </summary>
    
      <category term="MySQL" scheme="http://sergiochan.github.io/tags/MySQL/"/>
    
      <category term="Ubuntu" scheme="http://sergiochan.github.io/tags/Ubuntu/"/>
    
      <category term="Linux服务器笔记" scheme="http://sergiochan.github.io/categories/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[iOS 静态库封装和使用方法]]></title>
    <link href="http://sergiochan.github.io/2014/12/10/iOS-%E9%9D%99%E6%80%81%E5%BA%93%E5%B0%81%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://sergiochan.github.io/2014/12/10/iOS-静态库封装和使用方法/</id>
    <published>2014-12-10T12:47:54.000Z</published>
    <updated>2015-12-18T13:13:14.000Z</updated>
    <content type="html"><![CDATA[<p>由于现在的任务是将之前已经进行了第一步demo的验证，我需要将demo里的需要的部分整理出来，封装成静态库，从而给其他开发者使用。iOS封装静态库在百度上已经有很多教程了，但是实际中我却遇到了这样的问题：</p>
<ul>
<li>静态库里的代码需要引用到其他静态库，不是简单的控件封装。</li>
<li>之前的项目大部分引用的文件都只是加在了Library和Header search path中，并没有真正添加在项目中。</li>
</ul>
<p>第一步，新建一个Framework&amp;Library -&gt;Cocoa Touch Static Library 的工程。<br>将我需要的代码文件添加进项目目录下。修改build setting，和之前完整的工程的配置基本一样即可。<br>对于引用到的其他静态库，确认它处于Link Binary With Libraries下。<br>再确认Library和Header search path指向了正确的头文件或库文件的路径。删除多余的库文件以保证最后的静态库体积最小。</p>
<p>第二步，选择真机环境编译，这里编译的target选的不一样，编译出来的静态库可运行环境就不一样。由于我需要编译的这个功能也只能运行在真机上，所以就直接在真机环境下编译即可。</p>
<p>第三步，编译之前注意选择Build Phase-&gt;Copy Files，将之后需要展示出来的头文件添加进去。注意Copy only when installing不要选中。</p>
<p>第四步可以编译了，跑出来的静态库如果没有报错就是可以使用的了。在使用这个静态库的时候也一定要注意所有的头文件和库文件，包括静态库需要指向的头文件，都要在新工程的build setting里设置清楚。实验证明= =如果一个静态库里会用到其他静态库的话，是可以把静态库压的更小的。。。并且引用还是比较好解决的，只要保证各种路径都指向正确。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>由于现在的任务是将之前已经进行了第一步demo的验证，我需要将demo里的需要的部分整理出来，封装成静态库，从而给其他开发者使用。iOS封装静态库在百度上已经有很多教程了，但是实际中我却遇到了这样的问题：</p>
<ul>
<li>静态库里的代码需要引用到其他静态库，不是简]]>
    </summary>
    
      <category term="iOS静态库" scheme="http://sergiochan.github.io/tags/iOS%E9%9D%99%E6%80%81%E5%BA%93/"/>
    
      <category term="iOS菜鸟心得" scheme="http://sergiochan.github.io/categories/iOS%E8%8F%9C%E9%B8%9F%E5%BF%83%E5%BE%97/"/>
    
  </entry>
  
</feed>
