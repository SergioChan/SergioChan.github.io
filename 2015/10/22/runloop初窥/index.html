<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>runloop初窥 | Sergio Chan</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="Professional Hacker and Manager. &lt;br/&gt; Founded Hackathon team hACKbUSTER.&lt;em&gt;&lt;/a&gt;.">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="runloop初窥 | Sergio Chan">
    <meta name="twitter:description" content="Professional Hacker and Manager. &lt;br/&gt; Founded Hackathon team hACKbUSTER.&lt;em&gt;&lt;/a&gt;.">

    <meta property="og:type" content="article">
    <meta property="og:title" content="runloop初窥 | Sergio Chan">
    <meta property="og:description" content="Professional Hacker and Manager. &lt;br/&gt; Founded Hackathon team hACKbUSTER.&lt;em&gt;&lt;/a&gt;.">

    
    <meta name="author" content="Sergio Chan">
    
    <link rel="stylesheet" href="/css/vno.css" type="text/css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" type="text/css">

    
    <link rel="icon" href="/favicon.ico">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://sergiochan.github.io/2015/10/22/runloop初窥/"/>

    
    <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?030a47db2df6601bda0225610cd6c323";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>

</head>

<body class="home-template no-js">

    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Sergio Chan 的主页"><img src="https://avatars2.githubusercontent.com/u/10103766?v=3&amp;s=460" width="80" alt="Sergio Chan logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Sergio Chan">Sergio Chan</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">Full Stack, Born hacker, Professional Manager</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">Crazy fan of Hackathons all around the world.<br/> Founded Hackathon team hACKbUSTER.<em></a></p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/archives" title="" class="blog-button">Blog</a></li>
            
              <li class="navigation__item"><a href="/bio">Biography</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/3089081773/profile?topnav=1&amp;wvr=6" title="My Weibo" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/SergioChan" title="My Github" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/Sergio2Chan" title="Twitter" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>


<li class="navigation__item">
  <a href="https://dribbble.com/SergioChan" title="Dribbble" target="_blank">
    <i class='social fa fa-dribbble'></i>
    <span class="label">Dribbble</span>
  </a>
</li>

<!-- Linkedin -->

  <li class="navigation__item">
    <a href="http://www.linkedin.com/in/sergiochan" title="Linkedin" target="_blank">
      <i class='social fa fa-linkedin'></i>
      <span class="label">Linkedin</span>
    </a>
  </li>




  <li class="navigation__item">
    <a href="mailto:cyh9211@icloud.com" title="Email" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-slate"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2015-10-22T11:36:23.000Z" class="post-list__meta--date date">2015-10-22</time> &#8226; <span class="post-meta__tags tags">于&nbsp;
  <a class="tag-link" href="/tags/NSThread/">NSThread</a>, <a class="tag-link" href="/tags/iOS/">iOS</a>, <a class="tag-link" href="/tags/runloop/">runloop</a>
</span>
    </div>
    <h1 class="post-title">runloop初窥</h1>
  </header>

  <section class="post article-entry">
    <script src="/assets/js/APlayer.min.js"> </script><h2 id="u5148_u6765_u8BF4_u4E00_u4E2A_u5F88_u7B80_u5355_u7684_u5B9E_u4F8B"><a href="#u5148_u6765_u8BF4_u4E00_u4E2A_u5F88_u7B80_u5355_u7684_u5B9E_u4F8B" class="headerlink" title="先来说一个很简单的实例"></a>先来说一个很简单的实例</h2><p>在scrollView中添加一个timer来刷新视图的时候，如果只是简单的声明</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">self.timer = [NSTimer <span class="string">scheduledTimerWithTimeInterval:</span><span class="number">1.0</span>f <span class="string">target:</span>self <span class="string">selector:</span><span class="meta">@selector</span>(<span class="string">timeUpdate:</span>) <span class="string">userInfo:</span>nil <span class="string">repeats:</span>YES];</span><br></pre></td></tr></table></figure>
<p>那么当你滑动或者保持你的手指在scrollView上的时候，timer是不会被响应的，这不是因为刷新视图的操作被占用，而是因为当你没有显式声明的时候，你所定义的timer默认都是加在主线程上，并且，当你在对scrollView进行操作的时候，你的timer的事件根本不会被响应到，这就得说到runloop了。而runloop也是底层原理中相当重要的一部分。我们先从它说起。</p>
<h2 id="u4EC0_u4E48_u662Frunloop"><a href="#u4EC0_u4E48_u662Frunloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h2><p>Runloop，顾名思义就是运行的循环。简单理解就是多线程机制中的基础，它能够接收外部事件的输入，并且在有事件的时候保持运行，在没有事件的时候进入休眠。并且它对于线程的消息处理机制进行了很好的封装。</p>
<p>对于线程来说，每一个线程都有一个runloop对象，是否能向某个线程的runloop发送事件取决于你是否启动了这个runloop，系统会默认在你的程序启动的时候运行主线程上的runloop，但是你自定义创建出来的线程可以不需要运行runloop，一些第三方框架，例如AFNetworking，就有在自己的线程上维护一个runloop对象。</p>
<p>在 Core Foundation 里面关于 RunLoop 有5个类:</p>
<ul>
<li>CFRunLoopRef</li>
<li>CFRunLoopModeRef</li>
<li>CFRunLoopSourceRef </li>
<li>CFRunLoopTimerRef </li>
<li>CFRunLoopObserverRef</li>
</ul>
<p>他们的关系可以从NSRunloop对象的结构定义中得出。首先，runloop对象在Cocoa和Core Foundation中都有实现，但是他们做了很好的桥接，你可以直接调用</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">CFRunLoopRef runLoopRef</span> = currentThreadRunLoop.getCFRunLoop;</span><br></pre></td></tr></table></figure>
<p>来获取一个CoreFoundation中的runloop对象。然后，当你在查看NSRunloop的结构的时候，你应该能看到：</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">&lt;CFRunLoop <span class="number">0</span>x7fd360f5af30 [<span class="number">0</span>x1090a1180]&gt;&#123;wakeup <span class="attr">port</span> = <span class="number">0</span>x4507, <span class="attr">stopped</span> = <span class="literal">false</span>, <span class="attr">ignoreWakeUps</span> = <span class="literal">true</span>, </span><br><span class="line">current <span class="attr">mode</span> = (none),</span><br><span class="line">common <span class="attr">modes</span> = &lt;CFBasicHash <span class="number">0</span>x7fd360f5a470 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">type</span> = mutable set, <span class="attr">count</span> = <span class="number">1</span>,</span><br><span class="line"><span class="attr">entries</span> =&gt;</span><br><span class="line">	<span class="number">2</span> : &lt;CFString <span class="number">0</span>x10907d080 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">contents</span> = <span class="string">"kCFRunLoopDefaultMode"</span>&#125;&#125;,</span><br><span class="line">common mode <span class="attr">items</span> = (<span class="literal">null</span>),</span><br><span class="line"><span class="attr">modes</span> = &lt;CFBasicHash <span class="number">0</span>x7fd360f5b2b0 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">type</span> = mutable set, <span class="attr">count</span> = <span class="number">1</span>,</span><br><span class="line"><span class="attr">entries</span> =&gt;</span><br><span class="line">	<span class="number">2</span> : &lt;CFRunLoopMode <span class="number">0</span>x7fd360f5aff0 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">name</span> = kCFRunLoopDefaultMode, port <span class="attr">set</span> = <span class="number">0</span>x4703, timer <span class="attr">port</span> = <span class="number">0</span>x4803, </span><br><span class="line">	<span class="attr">sources0</span> = (<span class="literal">null</span>),</span><br><span class="line">	<span class="attr">sources1</span> = (<span class="literal">null</span>),</span><br><span class="line">	<span class="attr">observers</span> = &lt;CFArray <span class="number">0</span>x7fd360f5b1a0 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">type</span> = mutable-small, <span class="attr">count</span> = <span class="number">1</span>, <span class="attr">values</span> = (</span><br><span class="line">	<span class="number">0</span> : &lt;CFRunLoopObserver <span class="number">0</span>x7fd360f5c7f0 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">valid</span> = Yes, <span class="attr">activities</span> = <span class="number">0</span>xfffffff, <span class="attr">repeats</span> = Yes, <span class="attr">order</span> = <span class="number">0</span>, <span class="attr">callout</span> = currentRunLoopObserver (<span class="number">0</span>x10855b340), <span class="attr">context</span> = &lt;CFRunLoopObserver context <span class="number">0</span>x7fd361213d70&gt;&#125;</span><br><span class="line">)&#125;,</span><br><span class="line">	<span class="attr">timers</span> = &lt;CFArray <span class="number">0</span>x7fd360e020d0 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">type</span> = mutable-small, <span class="attr">count</span> = <span class="number">1</span>, <span class="attr">values</span> = (</span><br><span class="line">	<span class="number">0</span> : &lt;CFRunLoopTimer <span class="number">0</span>x7fd360e01f90 [<span class="number">0</span>x1090a1180]&gt;&#123;<span class="attr">valid</span> = Yes, <span class="attr">firing</span> = No, <span class="attr">interval</span> = <span class="number">1</span>, <span class="attr">tolerance</span> = <span class="number">0</span>, next fire <span class="attr">date</span> = <span class="number">463742311</span> (-<span class="number">2.53606331</span> @ <span class="number">23607719248079</span>), <span class="attr">callout</span> = (NSTimer) [SCCustomThread handleTimerTask] (<span class="number">0</span>x1086416f1 / <span class="number">0</span>x10855b560) (/Users/useruser/Library/Developer/CoreSimulator/Devices/<span class="number">424</span>D3C6E-<span class="number">8</span>DC0-<span class="number">418</span>B-A2EC-<span class="number">8</span>EDF89507348/data/Containers/Bundle/Application/<span class="number">4</span>D07AF38-<span class="number">9</span>BFC-<span class="number">4617</span>-BAE0-<span class="number">4</span>CB0D7966CC8/runloopTest.app/runloopTest), <span class="attr">context</span> = &lt;CFRunLoopTimer context <span class="number">0</span>x7fd360e01f70&gt;&#125;</span><br><span class="line">)&#125;,</span><br><span class="line">	currently <span class="number">463742313</span> (<span class="number">23610255156065</span>) / soft deadline <span class="keyword">in</span>: <span class="number">1.84467441</span>e+<span class="number">10</span> sec (@ <span class="number">23607719248079</span>) / hard deadline <span class="keyword">in</span>: <span class="number">1.84467441</span>e+<span class="number">10</span> sec (@ <span class="number">23607719248079</span>)</span><br><span class="line">&#125;,&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到一个runloop对象包含各种Mode——currentMode，common mode，modes等等，这里的示例我只指定了一个defaultMode。每个mode对应了source，observers和timers。</p>
<blockquote>
<p>也许你会注意到 source 包括了source0和source1两个版本。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程。</li>
</ul>
</blockquote>
<p>CFRunLoopObserver类型的对象也可以称之为观察者。每个观察者都包含了一个回调，当runloop的状态发生变化时，你可以通过回调来知道当前的状态。</p>
<h2 id="Mode"><a href="#Mode" class="headerlink" title="Mode"></a>Mode</h2><p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="image"></p>
<p>在你的程序中，runloop的过程实际上是一个无限循环的循环体，这个循环体是由你的程序来运行的。主线程的runloop由于系统已经实现并且没有它程序就不能运行，因此不需要我们手动去运行这个runloop。然而如果我们需要在自定义的线程中使用到runloop，我们则需要用一个do…while循环来驱动它。而runloop对象负责不断地在循环体中运行传进来的事件，然后将事件发给相应的响应。</p>
<blockquote>
<p>如果你打开你的程序的main.m，你就会发现其实主线程的runloop就是在main函数中进行的，并且系统已经为你生成好了autoreleasepool，因此你也无需操心主线程上的内存释放到底是在什么时候执行了：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据响应源的不同，runloop也被分成了许多种不同的模式，这就是被Cocoa和Core Foundation都封装了的runloopMode。主要是这么几种：</p>
<ul>
<li>NSDefaultRunLoopMode: 大多数工作中默认的运行方式。</li>
<li>NSConnectionReplyMode: 使用这个Mode去监听NSConnection对象的状态。</li>
<li>NSModalPanelRunLoopMode: 使用这个Mode在Model Panel情况下去区分事件(OS X开发中会遇到)。</li>
<li>NSEventTrackingRunLoopMode: 使用这个Mode去跟踪来自用户交互的事件（比如UITableView上下滑动）。</li>
<li>NSRunLoopCommonModes: 这是一个伪模式，其为一组run loop mode的集合。如果将Input source加入此模式，意味着关联Input source到Common Modes中包含的所有模式下。在iOS系统中NSRunLoopCommonMode包含NSDefaultRunLoopMode、NSTaskDeathCheckMode、NSEventTrackingRunLoopMode.可使用CFRunLoopAddCommonMode方法向Common Modes中添加自定义mode。</li>
</ul>
<p>在文首的情况中，我们可以根据苹果官方文档的定义知道，当你在滑动页面的时候，主线程的runloop自动进入了NSEventTrackingRunLoopMode，而你的timer只是运行在DefaultMode下，所以不能响应。那么最简单的办法就是将你的timer添加在其他的mode下，像这样即可：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[[NSRunLoop currentRunLoop]</span> <span class="selector-tag">addTimer</span><span class="selector-pseudo">:self.timer</span> <span class="selector-tag">forMode</span><span class="selector-pseudo">:NSRunLoopCommonModes</span>];</span><br></pre></td></tr></table></figure>
<p>需要注意的是CommonModes其实并不是一种Mode，而是一个集合。因此runloop并不能在CommonModes下运行，相反，你可以将需要输入的事件源添加为这个mode，这样无论runloop运行在哪个mode下都可以响应这个输入事件，否则这个事件将不会得到响应。</p>
<h2 id="Input_Source"><a href="#Input_Source" class="headerlink" title="Input Source"></a>Input Source</h2><p>输入源包括三种，端口，自定义输入源和performSelector的消息。根据上面的图我们可以看出，在runloop接收到消息并执行了指定方法的时候，它会执行runUntilDate:这个方法来退出当前循环。</p>
<p>端口源是基于Mach port的，其他进程或线程可以通过端口来发送消息。这里的知识点需要深入到Mach，就已经比较晦涩难懂了……这里你只需要知道你可以用Cocoa封装的NSPort对象来进行线程之间的通信，而这种通信方式所产生的事件就是通过端口源来传入runloop的。关于Mach port的更深层介绍可以看<a href="http://segmentfault.com/a/1190000002400329" target="_blank" rel="external">这篇</a>。</p>
<p>自定义输入源。Core Foundation提供了CFRunLoopSourceRef类型的相关函数，可以用来创建自定义输入源。</p>
<p>performSelector输入源:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在主线程的Run Loop下执行指定的 @selector 方法</span></span><br><span class="line"><span class="string">performSelectorOnMainThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span></span><br><span class="line"><span class="string">performSelectorOnMainThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span><span class="string">modes:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前线程的Run Loop下执行指定的 @selector 方法</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">onThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">onThread:</span><span class="string">withObject:</span><span class="string">waitUntilDone:</span><span class="string">modes:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在当前线程的Run Loop下延迟加载指定的 @selector 方法</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">withObject:</span><span class="string">afterDelay:</span></span><br><span class="line"><span class="string">performSelector:</span><span class="string">withObject:</span><span class="string">afterDelay:</span><span class="string">inModes:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//取消当前线程的调用</span></span><br><span class="line"><span class="string">cancelPreviousPerformRequestsWithTarget:</span></span><br><span class="line"><span class="string">cancelPreviousPerformRequestsWithTarget:</span><span class="string">selector:</span><span class="string">object:</span></span><br></pre></td></tr></table></figure>
<h2 id="runloop_u751F_u547D_u5468_u671F"><a href="#runloop_u751F_u547D_u5468_u671F" class="headerlink" title="runloop生命周期"></a>runloop生命周期</h2><p>每一次runloop其实都是一次循环，runloop会在循环中执行runUntilDate: 或者runMode: beforeDate: 来开始每一个循环。而每一个循环又分为下面几个阶段，也就是runloop的生命周期：</p>
<ul>
<li>kCFRunLoopEntry 进入循环</li>
<li>kCFRunLoopBeforeTimers 先接收timer的事件</li>
<li>kCFRunLoopBeforeSources 接收来自input source的事件</li>
<li>kCFRunLoopBeforeWaiting 如果没有事件，则准备进入休眠模式，在这里，如果没有事件传入，runloop会运行直到循环中给定的日期，如果你给的是distantFuture，那么这个runloop会无限等待下去</li>
<li>kCFRunLoopAfterWaiting 从休眠中醒来，直接回到kCFRunLoopBeforeTimers状态</li>
<li>kCFRunLoopExit 退出循环</li>
</ul>
<p>这些状态也是一个枚举类型，系统是这么定义的，你可以使用observer来观测到这些状态：</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Run Loop Observer Activities */</span></span><br><span class="line">typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123;</span><br><span class="line">    kCFRunLoopEntry = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>),</span><br><span class="line">    kCFRunLoopBeforeTimers = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>),</span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>),</span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>),</span><br><span class="line">    kCFRunLoopAfterWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>),</span><br><span class="line">    kCFRunLoopExit = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>),</span><br><span class="line">    kCFRunLoopAllActivities = <span class="number">0x0FFFFFFF</span>U</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们下面做一个测试，在demo中我们定义了一个新的线程类，这样我们可以自己启动和维护它的runloop对象。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Thread Enter"</span>);</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@"This is a test thread"</span>];</span><br><span class="line">        <span class="built_in">NSRunLoop</span> *currentThreadRunLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">// 或者</span></span><br><span class="line">        <span class="comment">// CFRunLoopRef currentThreadRunLoop = CFRunLoopGetCurrent();</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFRunLoopObserverContext</span> context = &#123;<span class="number">0</span>, (__bridge <span class="keyword">void</span> *)(<span class="keyword">self</span>), <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">        <span class="built_in">CFRunLoopObserverRef</span> observer = <span class="built_in">CFRunLoopObserverCreate</span>(kCFAllocatorDefault, kCFRunLoopAllActivities, <span class="literal">YES</span>, <span class="number">0</span>, &amp;currentRunLoopObserver, &amp;context);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (observer) &#123;</span><br><span class="line">            <span class="built_in">CFRunLoopRef</span> runLoopRef = currentThreadRunLoop.getCFRunLoop;</span><br><span class="line">            <span class="built_in">CFRunLoopAddObserver</span>(runLoopRef, observer, kCFRunLoopDefaultMode);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个Timer，重复调用来驱动Run Loop</span></span><br><span class="line">        <span class="comment">//[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(handleTimerTask) userInfo:nil repeats:YES];</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            [currentThreadRunLoop runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:<span class="number">3</span>]];</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入源或者timer对于runloop来说是必要条件，如果没有添加任何输入源，则runloop根本不会启动，所以上面的代码中添加timer的操作，实际上是添加了一个默认的事件输入源，能让runloop保持运行。但是实际上，当你创建好一个runloop对象后，任何输入的事件都可以触发runloop的启动。</p>
<p>例如下面的：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(selectorTest) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure>
<p>记住，如果你需要自己来启动和维护runloop的话，核心就在于一个do…while循环，你可以为runloop的跳出设置一个条件，也可以让runloop无限进行下去。在runloop没有接收到事件进入休眠状态之后，如果调用performSelector，runloop的状态变化如下：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">Current thread <span class="keyword">Run</span><span class="bash"> Loop activity: kCFRunLoopAfterWaiting</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">fuck</span></span><br><span class="line"><span class="bash">fuck_1</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopExit</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopExit</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeWaiting</span></span><br></pre></td></tr></table></figure>
<p>在这里我连续调用了两次performSelector，可以看到runloop也经历了两个循环，而如果只调用一次的话，不会有多出来的那次runloop（你可以自己尝试一下），这是否说明每一次performSelector执行完毕之后都会立即结束当前runloop开始新的，苹果的官方文档里有一句话：</p>
<blockquote>
<p>The run loop processes all queued perform selector calls each time through the loop, rather than processing one during each loop iteration</p>
</blockquote>
<p>应该意思是并不是像上面看到的结果那样每一次循环执行一次，而是有一个待执行的操作队列。如果我同时执行四次performSelector，像这样：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">[self <span class="string">performSelector:</span><span class="meta">@selector</span>(selectorTest) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="meta">@selector</span>(selectorTest_1) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="meta">@selector</span>(selectorTest_2) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br><span class="line">   [self <span class="string">performSelector:</span><span class="meta">@selector</span>(selectorTest_2) <span class="string">onThread:</span>self.runLoopThread <span class="string">withObject:</span>nil <span class="string">waitUntilDone:</span>NO];</span><br></pre></td></tr></table></figure>
<p>实际上得到的结果和上面是一样的，然而当我将他们的waitUntilDone参数都设置为YES之后，我们可以看到不一样的地方：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">Thread Enter</span><br><span class="line">Current thread <span class="keyword">Run</span><span class="bash"> Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">fuck</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopExit</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">fuck_1</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopExit</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">fuck_2</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopExit</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">fuck_2</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopExit</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopEntry</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeTimers</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeSources</span></span><br><span class="line"><span class="bash">Current thread Run Loop activity: kCFRunLoopBeforeWaiting</span></span><br></pre></td></tr></table></figure>
<p>你可以看到每一个performSelector操作都单独执行了一个runloop，从苹果的文档中我们可以找到这个方法的定义：</p>
<blockquote>
<ul>
<li>performSelector:onThread:withObject:waitUntilDone:</li>
<li>performSelector:onThread:withObject:waitUntilDone:modes:</li>
</ul>
<p>Performs the specified selector on any thread for which you have an NSThread object. These methods give you the option of blocking the current thread until the selector is performed.</p>
</blockquote>
<p>也就是说，waitUntilDone意味着这个操作是否会在当前线程阻塞其他的输入源，如果等于True，则每一次runloop循环只会处理这一个selector的调用，如果为False，则队列中后面等待着的selector调用都会在同一次runloop循环中执行。至于上文的执行了两个runloop循环的现象，我猜测应该是当runloop从休眠模式被唤醒的时候，当前循环执行完唤醒的操作后就会立即结束，释放掉之前可能累积下来的内存，然后开始新的循环，将队列中的其他输入逐个放进runloop循环中执行。</p>

  </section>

</article>


<section class="post-comments">
  <!-- 多说评论框 start -->
  <div class="ds-thread" data-thread-key="http://sergiochan.github.io/2015/10/22/runloop初窥/" data-title="runloop初窥" data-url="http://sergiochan.github.io/2015/10/22/runloop初窥/"></div>
  <!-- 多说评论框 end -->
  <!-- 多说公共JS代码 start (一个网页只需插入一次) -->
  <script type="text/javascript">
  var duoshuoQuery = {short_name:"sergiochan"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共JS代码 end -->
</section>



            <footer class="footer">
    <span class="footer__copyright">
        本站点采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
    </span>
    <span class="footer__copyright">
        &copy; 2014 - 2018 本站由 <a href="/">@Sergio Chan</a> 创建,
    </span>
</footer>

        </div>
    </div>

    <script src="http://cdn.bootcss.com/jquery/2.1.4/jquery.min.js" type="text/javascript"></script>
    <script src="/js/main.js" type="text/javascript"></script>

     
</body>
</html>
